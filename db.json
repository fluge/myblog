{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/fluge.png","path":"fluge.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/fluge.png","path":"img/fluge.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner1.jpg","path":"img/banner1.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"909a2b39bf012a9bb70865f9ba4569a08b165adb","modified":1480069841000},{"_id":"source/.DS_Store","hash":"ebe2b801fcd5bf5f1cd98fdc72b848a5d13d48a3","modified":1482401141000},{"_id":"source/favicon.ico","hash":"bc48d2f86be42c36afdbcd2bdd439d24e0ed48a6","modified":1482393870000},{"_id":"source/fluge.png","hash":"9e89815d5d3026403dac5915eb296cca85c1f356","modified":1482398408000},{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1482395495000},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1482395495000},{"_id":"themes/jacman/.DS_Store","hash":"d9dc24148482a9f2fa02a05cce870421bc91103b","modified":1482402584000},{"_id":"themes/jacman/README_zh.md","hash":"d6014b16eaccc97dc54a7779c9e36003752410e1","modified":1482395495000},{"_id":"themes/jacman/_config.yml","hash":"9f9daba6bca39238987b475c2e8c9734c336458a","modified":1482402747000},{"_id":"themes/jacman/README.md","hash":"75a5c9fbd7c9cec4d2f277042d2fee550e4936be","modified":1482395495000},{"_id":"source/_posts/HashMap并发的死循环.md","hash":"c17d693d624f96f7cd41e360a61040c567e81299","modified":1483005077000},{"_id":"source/_posts/IP初识.md","hash":"766e7e8a83a452fbdb9eae161d40066bcea444aa","modified":1481680776000},{"_id":"source/_posts/ICMP协议和UDP协议.md","hash":"6051685be93f8e5ea3f02ffdd32c1fceafc096a6","modified":1482995897000},{"_id":"source/_posts/java内存模型的认识.md","hash":"1c2d11e7bd30c4ab8de25b08c67aefcf9bf75333","modified":1483608207000},{"_id":"source/_posts/Java里的hasMap和golang里的map.md","hash":"d7c5f5e9284445b70671c01444104cee460196d8","modified":1482387864000},{"_id":"source/_posts/session和cookie.md","hash":"2c310196aceb6d90d42f8fa9c03ba373a5c6442b","modified":1482386674000},{"_id":"source/_posts/并发下的HashMap.md","hash":"b6b43c221326c306f902ae4e39295c719158b8d7","modified":1483614968000},{"_id":"source/_posts/第一篇博客.md","hash":"6a913d84138679cad8796e8b707d326fd4fdd365","modified":1480912390000},{"_id":"source/_posts/跨域.md","hash":"13070eb751ad47204799369b9b9258574428c1ed","modified":1482828294000},{"_id":"source/_posts/golang的切片和Java的动态数组.md","hash":"c39c071c75b674b6f2b68eebaba9fdcbca4c7966","modified":1483000405000},{"_id":"source/about/index.md","hash":"abf5bfff51a45c7a244d7daa636283ce31a057ae","modified":1482399912000},{"_id":"source/categories/index.md","hash":"f4183123ad94941cee8aeb3dbfa617228ece8f7a","modified":1480325818000},{"_id":"source/tags/index.md","hash":"25f96387fa50d21e559d75b93cd8b7fc6cbe34ff","modified":1480325776000},{"_id":"source/search/index.md","hash":"f8a5489cbe4ec6656f65edfd48eb4937faa5ee9b","modified":1482400088000},{"_id":"themes/jacman/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1482395495000},{"_id":"themes/jacman/.git/config","hash":"2d3ae691d19a816889480acb832a3813f5ad7605","modified":1482395495000},{"_id":"themes/jacman/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1482395474000},{"_id":"themes/jacman/.git/index","hash":"47135f4de86125deedf240a873a25777ab1c3d11","modified":1482473309000},{"_id":"themes/jacman/.git/packed-refs","hash":"facb04d8a7e4221a4b0b3dc3062a8ca586ade15d","modified":1482395495000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1482395495000},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1482395495000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1482395495000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1482395495000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1482395495000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1482395495000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1482395495000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1482395495000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1482395495000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1482395495000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1482395495000},{"_id":"themes/jacman/source/.DS_Store","hash":"d19a76ad1b890a34e23d05155a267f922240a883","modified":1482402568000},{"_id":"themes/jacman/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1482395474000},{"_id":"themes/jacman/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1482395474000},{"_id":"themes/jacman/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1482395474000},{"_id":"themes/jacman/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1482395474000},{"_id":"themes/jacman/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1482395474000},{"_id":"themes/jacman/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1482395474000},{"_id":"themes/jacman/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1482395474000},{"_id":"themes/jacman/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1482395474000},{"_id":"themes/jacman/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1482395474000},{"_id":"themes/jacman/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1482395474000},{"_id":"themes/jacman/.git/logs/HEAD","hash":"727330d93954db5c0f391a5a96996eeb99c11a93","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1482395495000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1482395495000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1482395495000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1482395495000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1482395495000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1482395495000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1482395495000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1482395495000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1482395495000},{"_id":"themes/jacman/source/css/.DS_Store","hash":"689ec91b9ae7761bf528b24be5f9240461a1a52d","modified":1482402568000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1482395495000},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1482395495000},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1482395495000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1482395495000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1482395495000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1482395495000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1482395495000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1482395495000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1482395495000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1482395495000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1482395495000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1482395495000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1482395495000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1482395495000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1482395495000},{"_id":"themes/jacman/source/img/author.jpg","hash":"864cb30fc8a6b84e857bf7e741e8ed704ba2d6fb","modified":1482398755000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1482395495000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1482395495000},{"_id":"themes/jacman/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1482399266000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1482395495000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1482395495000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1482395495000},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1482395495000},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1482395495000},{"_id":"themes/jacman/source/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1482395495000},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1482395495000},{"_id":"themes/jacman/source/img/fluge.png","hash":"1991d9ad0669bebb8c7485ee86c02b13779f3897","modified":1482398488000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1482395495000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1482395495000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1482395495000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1482395495000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1482395495000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1482395495000},{"_id":"themes/jacman/source/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1482395495000},{"_id":"themes/jacman/.git/refs/heads/master","hash":"51d4013e66aa8b536ba9b382ed64385114d32d9a","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1482395495000},{"_id":"themes/jacman/.git/objects/pack/pack-a480b7f46fbe82dc16372f3231cb5d8788ae83a4.idx","hash":"a4e7dab31fa0c007ea4f2c416af1da629b4b6e2c","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1482395495000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1482395495000},{"_id":"themes/jacman/source/css/_base/.DS_Store","hash":"a3ed810fb1471af792e2bd50a715d1ceff0e9238","modified":1482402574000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1482395495000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1482401504000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1482395495000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1482395495000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1482395495000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1482395495000},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1482395495000},{"_id":"themes/jacman/.git/logs/refs/heads/master","hash":"727330d93954db5c0f391a5a96996eeb99c11a93","modified":1482395495000},{"_id":"themes/jacman/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1482395495000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1482395495000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1482395495000},{"_id":"themes/jacman/source/img/banner1.jpg","hash":"33d2eea4bb53ab72ee66c1c70e9df38525f064b6","modified":1482399318000},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/HEAD","hash":"727330d93954db5c0f391a5a96996eeb99c11a93","modified":1482395495000},{"_id":"themes/jacman/.git/objects/pack/pack-a480b7f46fbe82dc16372f3231cb5d8788ae83a4.pack","hash":"8b281787b5f65f1910b660b970b5cb150ea685ad","modified":1482395495000},{"_id":"public/404.html","hash":"5d4b59bd02d02dffdc9f4d727b1c05a97e873225","modified":1483615000655},{"_id":"public/about/index.html","hash":"ccbd199e9168861e751fe64f38ce6d9db614578a","modified":1483615000655},{"_id":"public/categories/index.html","hash":"41b1b7632a771244c024de85cf667de0ffbc99b0","modified":1483615000656},{"_id":"public/tags/index.html","hash":"4b87de626cccb964145ea8fa82a67b00bdc9ff6e","modified":1483615000656},{"_id":"public/search/index.html","hash":"56141c71d7c9920881ec5155c24e44876ec52e48","modified":1483615000656},{"_id":"public/2017/01/03/java内存模型的认识/index.html","hash":"964b31873400d87b9eaaf4d0430c6873f07fd65a","modified":1483615000657},{"_id":"public/2016/11/25/第一篇博客/index.html","hash":"08e4aa16accb052c942c7ba6cfe62b9d4ecb8a45","modified":1483615000657},{"_id":"public/archives/index.html","hash":"1991453f0d3cf6a9b5f08d08ece53683dd5b6b3d","modified":1483615000657},{"_id":"public/archives/2016/index.html","hash":"6ee1e6843a16e54b9fc109f3b8e56b947f0f5e4e","modified":1483615000657},{"_id":"public/archives/2016/11/index.html","hash":"10f9861091e0b0a11f83ec3f3da11914ec7e0a3f","modified":1483615000657},{"_id":"public/archives/2016/12/index.html","hash":"4630a2ba7a0dde9f264a9fdaaf8eca860ba20988","modified":1483615000657},{"_id":"public/archives/2017/index.html","hash":"28a393e235dbab44a2663d19e041065c8ee78f22","modified":1483615000657},{"_id":"public/archives/2017/01/index.html","hash":"abcccec43db0c4cef34af7aa16fd1d61775e32e1","modified":1483615000657},{"_id":"public/categories/Java/index.html","hash":"eb482d2aae532c76041aac12651aa6e2e6675c17","modified":1483615000657},{"_id":"public/categories/TCP-IP/index.html","hash":"25f41850373dc1954613f081a1ce14678b7c5b9b","modified":1483615000657},{"_id":"public/categories/Java和golang/index.html","hash":"7cc2f1da420d36eed79ec9dba51dcd08f40b1ff5","modified":1483615000657},{"_id":"public/categories/web/index.html","hash":"a55175f11f2b76faeaaeb51d5474b67de6425c74","modified":1483615000657},{"_id":"public/categories/essay/index.html","hash":"439a601eb2cb84ee740e5ef8b457e7c9d7082e11","modified":1483615000657},{"_id":"public/tags/Java/index.html","hash":"cea5a170cf92c97e06e38b0761395ab13d002fa4","modified":1483615000657},{"_id":"public/tags/ip/index.html","hash":"c792aea13f0d4a3f5c8e62b49fe592051eca49f7","modified":1483615000657},{"_id":"public/tags/ICMP/index.html","hash":"e1da5582ae4ea50bd42d1f61b58f7ee182f82d8f","modified":1483615000657},{"_id":"public/tags/UDP/index.html","hash":"5959d9c0cd42257c0021e51b34250414118a7a69","modified":1483615000658},{"_id":"public/tags/golang/index.html","hash":"2a26b157d9e40352ae57e184d65673bcdaef946c","modified":1483615000658},{"_id":"public/tags/session/index.html","hash":"32a396b2fcc360233ea4bf56801f494600922157","modified":1483615000658},{"_id":"public/tags/cookie/index.html","hash":"e2d7210a8793dde12a3347439b920668f99764ed","modified":1483615000658},{"_id":"public/tags/start/index.html","hash":"c7174fe7947d343e050a9551023ef0b12ea4a7a9","modified":1483615000658},{"_id":"public/tags/cros/index.html","hash":"45bd301bd3ca3f810d0634e0f3a28efc38af43b0","modified":1483615000658},{"_id":"public/2016/12/29/并发下的HashMap/index.html","hash":"84f0d306d844d9ac6cbccb3904c9fd9e2a372ec0","modified":1483615000658},{"_id":"public/2016/12/22/session和cookie/index.html","hash":"0094ae8d02dc8b2d57162b4e62bde68270c5b286","modified":1483615000658},{"_id":"public/2016/12/15/HashMap并发的死循环/index.html","hash":"1d6e666d6845c4d4676423ba1f24324574b53311","modified":1483615000658},{"_id":"public/2016/12/14/跨域/index.html","hash":"4fec3f72fc37a06cd2f63fc7a53d1bb40fcd8fb8","modified":1483615000658},{"_id":"public/2016/12/12/ICMP协议和UDP协议/index.html","hash":"8e69285c75b4001edf56483e75a8e5c52d8ecbe1","modified":1483615000658},{"_id":"public/2016/12/05/Java里的hasMap和golang里的map/index.html","hash":"ec25c7c1cc435735a0295b8e528864513aedaca1","modified":1483615000658},{"_id":"public/2016/11/29/golang的切片和Java的动态数组/index.html","hash":"41fe9d853f3ca0362bdd980e8b9132e041a59bd1","modified":1483615000658},{"_id":"public/2016/11/28/IP初识/index.html","hash":"baf51b481c3e5e020558d55950e0d754a284d23c","modified":1483615000658},{"_id":"public/index.html","hash":"c20bd259453890254179958a609e8734fbfdc976","modified":1483615000658},{"_id":"public/favicon.ico","hash":"bc48d2f86be42c36afdbcd2bdd439d24e0ed48a6","modified":1483615000680},{"_id":"public/fluge.png","hash":"9e89815d5d3026403dac5915eb296cca85c1f356","modified":1483615000680},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483615000680},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483615000680},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483615000680},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483615000680},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483615000680},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483615000681},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1483615000681},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1483615000681},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1483615000681},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1483615000681},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1483615000681},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1483615000681},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1483615000681},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1483615000681},{"_id":"public/img/author.jpg","hash":"864cb30fc8a6b84e857bf7e741e8ed704ba2d6fb","modified":1483615000681},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1483615000681},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483615000681},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483615000681},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483615000682},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483615000682},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483615000682},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483615000682},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483615000682},{"_id":"public/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1483615000682},{"_id":"public/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1483615000682},{"_id":"public/img/fluge.png","hash":"1991d9ad0669bebb8c7485ee86c02b13779f3897","modified":1483615000682},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1483615000682},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1483615000682},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483615000683},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1483615001799},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1483615001803},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1483615001806},{"_id":"public/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1483615001806},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1483615001813},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1483615001813},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1483615001813},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1483615001813},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1483615001813},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1483615001813},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483615001813},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1483615001814},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483615001814},{"_id":"public/css/style.css","hash":"cd72f14476e629621a34025277859dcedb53c7ed","modified":1483615001814},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1483615001814},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1483615001814},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1483615001814},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1483615001814},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1483615001857},{"_id":"public/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1483615001857},{"_id":"public/img/banner1.jpg","hash":"33d2eea4bb53ab72ee66c1c70e9df38525f064b6","modified":1483615001883}],"Category":[{"name":"Java","_id":"cixka2bt80005khikgcd9l94p"},{"name":"TCP/IP","_id":"cixka2bto000akhik9uw6xsj4"},{"name":"Java和golang","_id":"cixka2bu1000pkhikydpfz21v"},{"name":"web","_id":"cixka2bu5000ukhikkgxtbxjx"},{"name":"essay","_id":"cixka2bu80010khik69vqm0f1"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>","date":"2016-11-25T10:30:41.000Z","updated":"2016-11-25T10:30:41.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cixka2bqu0000khiku4gccahg","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\">\n</script>\n\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>"},{"title":"about","date":"2016-11-28T09:36:35.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-28 17:36:35\ntype: \"about\"\n---\n","updated":"2016-12-22T09:45:12.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cixka2bt00002khikjnlvt1qn","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-11-28T09:36:35.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-11-28 17:36:35\ntype: \"categories\"\n---\n","updated":"2016-11-28T09:36:58.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cixka2bt30004khik6cxdms6c","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-11-28T09:36:00.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-11-28 17:36:00\ntype: \"tags\"\n---\n","updated":"2016-11-28T09:36:16.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cixka2bv7001ikhikxeoilnmv","content":"","excerpt":"","more":""},{"layout":"search","date":"2016-11-28T09:36:35.000Z","title":"search","_content":"","source":"search/index.md","raw":"---\nlayout: search\ndate: 2016-11-28 17:36:35\ntitle: search\n---\n","updated":"2016-12-22T09:48:08.000Z","path":"search/index.html","comments":1,"_id":"cixka2bva001jkhiky0dfb8en","content":"","excerpt":"","more":""}],"Post":[{"title":"HashMap并发的死循环","date":"2016-12-15T09:52:18.000Z","_content":"HashMap从设计上来说就不适合在并发的情况的下使用,因为HashMap每次在`put()`时，总会检查一遍对应桶的容量，如果桶满了，或者超过了设定的值，就会`reserve()`来进行扩容,然后通过`get()`来取出相应的值。这个过程在单线程下是没什么问题的，但是如果在并发的条件下，多个线程同时reserve桶，然后有线程这个时候执行`get()`就有可能产生死循环，造成CPU的100%占用，具体等会看源码。在Java里面有一个很老的hashtable就是加了锁的HashMap。现在Java中多线程里一般使用ConcurrentHashMap，至于为什么。会在下一篇博文里分析。\n### HashMap的rehash源代码  \n`put()`方法的Java8源码分析看我的[Java里的hashMap和golang里的map](https://fluge.github.io/2016/12/05/Java%E9%87%8C%E7%9A%84hasMap%E5%92%8Cgolang%E9%87%8C%E7%9A%84map/)，在Java8中优化了扩容的hash算法，更加高效。在这分析死循环用的是Java7的源码。更加清晰点。\n<!--more-->\n\n```java\nvoid resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return;\n        }\n         //创建一个新的Hash Table\n        Entry[] newTable = new Entry[newCapacity];\n        //将Old Hash Table上的数据迁移到New Hash Table上\n        transfer(newTable, initHashSeedAsNeeded(newCapacity))\n        table = newTable;\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    }\n/**\n * 将当前table的Entry转移到新的table中\n */\nvoid transfer(Entry[] newTable){\n    Entry[] src = table;\n    int newCapacity = newTable.length;\n    //下面这段代码的意思是:从OldTable里摘一个元素出来，然后放到NewTable中\n    for (int j = 0; j < src.length; j++) {\n        Entry<K,V> e = src[j];\n        if (e != null) {\n            src[j] = null;\n            do {\n                Entry<K,V> next = e.next;\n                //在新的table 中求得适合插入的位置\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            } while (e != null);// 可能导致死循环\n        }\n    }\n}\n```\n在单线程中的执行流程其实是很直观的:先对要插入的元素进行哈希，在数组中找到相应的位置，如果发生冲突就变成链表存储，在看桶有没有满。有就进`resize()`扩容操作。但是在多线程的时候由于扩容操作产生`环形链`，会造成`get()`方法命中时----Infinite Loop,然后CPU爆炸。  \n#### 举例分析(网上一个很经典的例子--引用自酷壳)  \n假设我们的hash算法是简单的key mod一下表的大小(即数组的长度),现在有两个线程：一个蓝色标注，一个红色标注。\n关键代码在`transfer()`中把旧的table的Entry转移到新的table中的时候\n\n```java\ndo {\n     Entry<K,V> next = e.next;<--假设红色线程执行到这里就被调度挂起了,蓝色线程全部执行\n     int i = indexFor(e.hash, newCapacity);\n     e.next = newTable[i];\n     newTable[i] = e;\n     e = next;\n} while (e != null);\n```\n两个线程在蓝色线程执行完后的情况。这个时候红色线程中的`e指向了key(3)`,而`next指向了key(7)`,但是在蓝色线程中`链表已经扩容完成`,并且`链表的顺序被反转` ,这个时候就有了环链的征兆了。e的下一个节点本来是next,经过蓝色线程扩容后变成了next下一个节点是e。就有很大的几率产生环形链。  \n![](http://ofa8x9gy9.bkt.clouddn.com/JAVA%20HASHMAP%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.jpg)  \n接着看,这个时候红色线程得到了执行的机会.被调度回来进行执行，\n先是执行`newTalbe[i] = e;`,然后是`e = next，导致了e指向了key(7)`,而下一次循环的`next = e.next导致了next指向了key(3)`。\n![](http://ofa8x9gy9.bkt.clouddn.com/HashMap03.jpg)  \n然后红色线程接着工作,把key(7)摘下来，放到newTable[i]的第一个,然后把`e和next往下移`。\n![](http://ofa8x9gy9.bkt.clouddn.com/HashMap04.jpg)   \n然后重点来了：`e.next = newTable[i]`导致`key(3).next指向了key(7)`。但是此时的`key(7).next 已经指向了key(3)`,环形链表就这样出现了。\n![](http://ofa8x9gy9.bkt.clouddn.com/HashMap05.jpg)     \n于是,当我们的线程一调用到,HashTable.get(11)时,悲剧就出现了——Infinite Loop。\n\n---\n参考：\n[疫苗：Java HashMap的死循环](http://coolshell.cn/articles/9606.html)  \n[不正当使用HashMap导致cpu 100%的问题追究](http://ifeve.com/hashmap-infinite-loop/) ","source":"_posts/HashMap并发的死循环.md","raw":"---\ntitle: HashMap并发的死循环\ndate: 2016-12-15 17:52:18\ncategories: \n- Java\ntags: \n- Java\n---\nHashMap从设计上来说就不适合在并发的情况的下使用,因为HashMap每次在`put()`时，总会检查一遍对应桶的容量，如果桶满了，或者超过了设定的值，就会`reserve()`来进行扩容,然后通过`get()`来取出相应的值。这个过程在单线程下是没什么问题的，但是如果在并发的条件下，多个线程同时reserve桶，然后有线程这个时候执行`get()`就有可能产生死循环，造成CPU的100%占用，具体等会看源码。在Java里面有一个很老的hashtable就是加了锁的HashMap。现在Java中多线程里一般使用ConcurrentHashMap，至于为什么。会在下一篇博文里分析。\n### HashMap的rehash源代码  \n`put()`方法的Java8源码分析看我的[Java里的hashMap和golang里的map](https://fluge.github.io/2016/12/05/Java%E9%87%8C%E7%9A%84hasMap%E5%92%8Cgolang%E9%87%8C%E7%9A%84map/)，在Java8中优化了扩容的hash算法，更加高效。在这分析死循环用的是Java7的源码。更加清晰点。\n<!--more-->\n\n```java\nvoid resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return;\n        }\n         //创建一个新的Hash Table\n        Entry[] newTable = new Entry[newCapacity];\n        //将Old Hash Table上的数据迁移到New Hash Table上\n        transfer(newTable, initHashSeedAsNeeded(newCapacity))\n        table = newTable;\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    }\n/**\n * 将当前table的Entry转移到新的table中\n */\nvoid transfer(Entry[] newTable){\n    Entry[] src = table;\n    int newCapacity = newTable.length;\n    //下面这段代码的意思是:从OldTable里摘一个元素出来，然后放到NewTable中\n    for (int j = 0; j < src.length; j++) {\n        Entry<K,V> e = src[j];\n        if (e != null) {\n            src[j] = null;\n            do {\n                Entry<K,V> next = e.next;\n                //在新的table 中求得适合插入的位置\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            } while (e != null);// 可能导致死循环\n        }\n    }\n}\n```\n在单线程中的执行流程其实是很直观的:先对要插入的元素进行哈希，在数组中找到相应的位置，如果发生冲突就变成链表存储，在看桶有没有满。有就进`resize()`扩容操作。但是在多线程的时候由于扩容操作产生`环形链`，会造成`get()`方法命中时----Infinite Loop,然后CPU爆炸。  \n#### 举例分析(网上一个很经典的例子--引用自酷壳)  \n假设我们的hash算法是简单的key mod一下表的大小(即数组的长度),现在有两个线程：一个蓝色标注，一个红色标注。\n关键代码在`transfer()`中把旧的table的Entry转移到新的table中的时候\n\n```java\ndo {\n     Entry<K,V> next = e.next;<--假设红色线程执行到这里就被调度挂起了,蓝色线程全部执行\n     int i = indexFor(e.hash, newCapacity);\n     e.next = newTable[i];\n     newTable[i] = e;\n     e = next;\n} while (e != null);\n```\n两个线程在蓝色线程执行完后的情况。这个时候红色线程中的`e指向了key(3)`,而`next指向了key(7)`,但是在蓝色线程中`链表已经扩容完成`,并且`链表的顺序被反转` ,这个时候就有了环链的征兆了。e的下一个节点本来是next,经过蓝色线程扩容后变成了next下一个节点是e。就有很大的几率产生环形链。  \n![](http://ofa8x9gy9.bkt.clouddn.com/JAVA%20HASHMAP%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.jpg)  \n接着看,这个时候红色线程得到了执行的机会.被调度回来进行执行，\n先是执行`newTalbe[i] = e;`,然后是`e = next，导致了e指向了key(7)`,而下一次循环的`next = e.next导致了next指向了key(3)`。\n![](http://ofa8x9gy9.bkt.clouddn.com/HashMap03.jpg)  \n然后红色线程接着工作,把key(7)摘下来，放到newTable[i]的第一个,然后把`e和next往下移`。\n![](http://ofa8x9gy9.bkt.clouddn.com/HashMap04.jpg)   \n然后重点来了：`e.next = newTable[i]`导致`key(3).next指向了key(7)`。但是此时的`key(7).next 已经指向了key(3)`,环形链表就这样出现了。\n![](http://ofa8x9gy9.bkt.clouddn.com/HashMap05.jpg)     \n于是,当我们的线程一调用到,HashTable.get(11)时,悲剧就出现了——Infinite Loop。\n\n---\n参考：\n[疫苗：Java HashMap的死循环](http://coolshell.cn/articles/9606.html)  \n[不正当使用HashMap导致cpu 100%的问题追究](http://ifeve.com/hashmap-infinite-loop/) ","slug":"HashMap并发的死循环","published":1,"updated":"2016-12-29T09:51:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2bsv0001khik9rpev2gw","content":"<p>HashMap从设计上来说就不适合在并发的情况的下使用,因为HashMap每次在<code>put()</code>时，总会检查一遍对应桶的容量，如果桶满了，或者超过了设定的值，就会<code>reserve()</code>来进行扩容,然后通过<code>get()</code>来取出相应的值。这个过程在单线程下是没什么问题的，但是如果在并发的条件下，多个线程同时reserve桶，然后有线程这个时候执行<code>get()</code>就有可能产生死循环，造成CPU的100%占用，具体等会看源码。在Java里面有一个很老的hashtable就是加了锁的HashMap。现在Java中多线程里一般使用ConcurrentHashMap，至于为什么。会在下一篇博文里分析。</p>\n<h3 id=\"HashMap的rehash源代码\"><a href=\"#HashMap的rehash源代码\" class=\"headerlink\" title=\"HashMap的rehash源代码\"></a>HashMap的rehash源代码</h3><p><code>put()</code>方法的Java8源码分析看我的<a href=\"https://fluge.github.io/2016/12/05/Java%E9%87%8C%E7%9A%84hasMap%E5%92%8Cgolang%E9%87%8C%E7%9A%84map/\" target=\"_blank\" rel=\"external\">Java里的hashMap和golang里的map</a>，在Java8中优化了扩容的hash算法，更加高效。在这分析死循环用的是Java7的源码。更加清晰点。<br><a id=\"more\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</div><div class=\"line\">        Entry[] oldTable = table;</div><div class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = oldTable.length;</div><div class=\"line\">        <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class=\"line\">            threshold = Integer.MAX_VALUE;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">         <span class=\"comment\">//创建一个新的Hash Table</span></div><div class=\"line\">        Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];</div><div class=\"line\">        <span class=\"comment\">//将Old Hash Table上的数据迁移到New Hash Table上</span></div><div class=\"line\">        transfer(newTable, initHashSeedAsNeeded(newCapacity))</div><div class=\"line\">        table = newTable;</div><div class=\"line\">        threshold = (<span class=\"keyword\">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 将当前table的Entry转移到新的table中</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable)</span></span>&#123;</div><div class=\"line\">    Entry[] src = table;</div><div class=\"line\">    <span class=\"keyword\">int</span> newCapacity = newTable.length;</div><div class=\"line\">    <span class=\"comment\">//下面这段代码的意思是:从OldTable里摘一个元素出来，然后放到NewTable中</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; src.length; j++) &#123;</div><div class=\"line\">        Entry&lt;K,V&gt; e = src[j];</div><div class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            src[j] = <span class=\"keyword\">null</span>;</div><div class=\"line\">            <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">                Entry&lt;K,V&gt; next = e.next;</div><div class=\"line\">                <span class=\"comment\">//在新的table 中求得适合插入的位置</span></div><div class=\"line\">                <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);</div><div class=\"line\">                e.next = newTable[i];</div><div class=\"line\">                newTable[i] = e;</div><div class=\"line\">                e = next;</div><div class=\"line\">            &#125; <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>);<span class=\"comment\">// 可能导致死循环</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在单线程中的执行流程其实是很直观的:先对要插入的元素进行哈希，在数组中找到相应的位置，如果发生冲突就变成链表存储，在看桶有没有满。有就进<code>resize()</code>扩容操作。但是在多线程的时候由于扩容操作产生<code>环形链</code>，会造成<code>get()</code>方法命中时—-Infinite Loop,然后CPU爆炸。  </p>\n<h4 id=\"举例分析-网上一个很经典的例子–引用自酷壳\"><a href=\"#举例分析-网上一个很经典的例子–引用自酷壳\" class=\"headerlink\" title=\"举例分析(网上一个很经典的例子–引用自酷壳)\"></a>举例分析(网上一个很经典的例子–引用自酷壳)</h4><p>假设我们的hash算法是简单的key mod一下表的大小(即数组的长度),现在有两个线程：一个蓝色标注，一个红色标注。<br>关键代码在<code>transfer()</code>中把旧的table的Entry转移到新的table中的时候</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">     Entry&lt;K,V&gt; next = e.next;&lt;--假设红色线程执行到这里就被调度挂起了,蓝色线程全部执行</div><div class=\"line\">     <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);</div><div class=\"line\">     e.next = newTable[i];</div><div class=\"line\">     newTable[i] = e;</div><div class=\"line\">     e = next;</div><div class=\"line\">&#125; <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>两个线程在蓝色线程执行完后的情况。这个时候红色线程中的<code>e指向了key(3)</code>,而<code>next指向了key(7)</code>,但是在蓝色线程中<code>链表已经扩容完成</code>,并且<code>链表的顺序被反转</code> ,这个时候就有了环链的征兆了。e的下一个节点本来是next,经过蓝色线程扩容后变成了next下一个节点是e。就有很大的几率产生环形链。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/JAVA%20HASHMAP%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.jpg\" alt=\"\"><br>接着看,这个时候红色线程得到了执行的机会.被调度回来进行执行，<br>先是执行<code>newTalbe[i] = e;</code>,然后是<code>e = next，导致了e指向了key(7)</code>,而下一次循环的<code>next = e.next导致了next指向了key(3)</code>。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/HashMap03.jpg\" alt=\"\"><br>然后红色线程接着工作,把key(7)摘下来，放到newTable[i]的第一个,然后把<code>e和next往下移</code>。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/HashMap04.jpg\" alt=\"\"><br>然后重点来了：<code>e.next = newTable[i]</code>导致<code>key(3).next指向了key(7)</code>。但是此时的<code>key(7).next 已经指向了key(3)</code>,环形链表就这样出现了。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/HashMap05.jpg\" alt=\"\"><br>于是,当我们的线程一调用到,HashTable.get(11)时,悲剧就出现了——Infinite Loop。</p>\n<hr>\n<p>参考：<br><a href=\"http://coolshell.cn/articles/9606.html\" target=\"_blank\" rel=\"external\">疫苗：Java HashMap的死循环</a><br><a href=\"http://ifeve.com/hashmap-infinite-loop/\" target=\"_blank\" rel=\"external\">不正当使用HashMap导致cpu 100%的问题追究</a> </p>\n","excerpt":"<p>HashMap从设计上来说就不适合在并发的情况的下使用,因为HashMap每次在<code>put()</code>时，总会检查一遍对应桶的容量，如果桶满了，或者超过了设定的值，就会<code>reserve()</code>来进行扩容,然后通过<code>get()</code>来取出相应的值。这个过程在单线程下是没什么问题的，但是如果在并发的条件下，多个线程同时reserve桶，然后有线程这个时候执行<code>get()</code>就有可能产生死循环，造成CPU的100%占用，具体等会看源码。在Java里面有一个很老的hashtable就是加了锁的HashMap。现在Java中多线程里一般使用ConcurrentHashMap，至于为什么。会在下一篇博文里分析。</p>\n<h3 id=\"HashMap的rehash源代码\"><a href=\"#HashMap的rehash源代码\" class=\"headerlink\" title=\"HashMap的rehash源代码\"></a>HashMap的rehash源代码</h3><p><code>put()</code>方法的Java8源码分析看我的<a href=\"https://fluge.github.io/2016/12/05/Java%E9%87%8C%E7%9A%84hasMap%E5%92%8Cgolang%E9%87%8C%E7%9A%84map/\">Java里的hashMap和golang里的map</a>，在Java8中优化了扩容的hash算法，更加高效。在这分析死循环用的是Java7的源码。更加清晰点。<br>","more":"</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</div><div class=\"line\">        Entry[] oldTable = table;</div><div class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = oldTable.length;</div><div class=\"line\">        <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class=\"line\">            threshold = Integer.MAX_VALUE;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">         <span class=\"comment\">//创建一个新的Hash Table</span></div><div class=\"line\">        Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];</div><div class=\"line\">        <span class=\"comment\">//将Old Hash Table上的数据迁移到New Hash Table上</span></div><div class=\"line\">        transfer(newTable, initHashSeedAsNeeded(newCapacity))</div><div class=\"line\">        table = newTable;</div><div class=\"line\">        threshold = (<span class=\"keyword\">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 将当前table的Entry转移到新的table中</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable)</span></span>&#123;</div><div class=\"line\">    Entry[] src = table;</div><div class=\"line\">    <span class=\"keyword\">int</span> newCapacity = newTable.length;</div><div class=\"line\">    <span class=\"comment\">//下面这段代码的意思是:从OldTable里摘一个元素出来，然后放到NewTable中</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; src.length; j++) &#123;</div><div class=\"line\">        Entry&lt;K,V&gt; e = src[j];</div><div class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            src[j] = <span class=\"keyword\">null</span>;</div><div class=\"line\">            <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">                Entry&lt;K,V&gt; next = e.next;</div><div class=\"line\">                <span class=\"comment\">//在新的table 中求得适合插入的位置</span></div><div class=\"line\">                <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);</div><div class=\"line\">                e.next = newTable[i];</div><div class=\"line\">                newTable[i] = e;</div><div class=\"line\">                e = next;</div><div class=\"line\">            &#125; <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>);<span class=\"comment\">// 可能导致死循环</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在单线程中的执行流程其实是很直观的:先对要插入的元素进行哈希，在数组中找到相应的位置，如果发生冲突就变成链表存储，在看桶有没有满。有就进<code>resize()</code>扩容操作。但是在多线程的时候由于扩容操作产生<code>环形链</code>，会造成<code>get()</code>方法命中时—-Infinite Loop,然后CPU爆炸。  </p>\n<h4 id=\"举例分析-网上一个很经典的例子–引用自酷壳\"><a href=\"#举例分析-网上一个很经典的例子–引用自酷壳\" class=\"headerlink\" title=\"举例分析(网上一个很经典的例子–引用自酷壳)\"></a>举例分析(网上一个很经典的例子–引用自酷壳)</h4><p>假设我们的hash算法是简单的key mod一下表的大小(即数组的长度),现在有两个线程：一个蓝色标注，一个红色标注。<br>关键代码在<code>transfer()</code>中把旧的table的Entry转移到新的table中的时候</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">     Entry&lt;K,V&gt; next = e.next;&lt;--假设红色线程执行到这里就被调度挂起了,蓝色线程全部执行</div><div class=\"line\">     <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);</div><div class=\"line\">     e.next = newTable[i];</div><div class=\"line\">     newTable[i] = e;</div><div class=\"line\">     e = next;</div><div class=\"line\">&#125; <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>两个线程在蓝色线程执行完后的情况。这个时候红色线程中的<code>e指向了key(3)</code>,而<code>next指向了key(7)</code>,但是在蓝色线程中<code>链表已经扩容完成</code>,并且<code>链表的顺序被反转</code> ,这个时候就有了环链的征兆了。e的下一个节点本来是next,经过蓝色线程扩容后变成了next下一个节点是e。就有很大的几率产生环形链。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/JAVA%20HASHMAP%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.jpg\" alt=\"\"><br>接着看,这个时候红色线程得到了执行的机会.被调度回来进行执行，<br>先是执行<code>newTalbe[i] = e;</code>,然后是<code>e = next，导致了e指向了key(7)</code>,而下一次循环的<code>next = e.next导致了next指向了key(3)</code>。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/HashMap03.jpg\" alt=\"\"><br>然后红色线程接着工作,把key(7)摘下来，放到newTable[i]的第一个,然后把<code>e和next往下移</code>。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/HashMap04.jpg\" alt=\"\"><br>然后重点来了：<code>e.next = newTable[i]</code>导致<code>key(3).next指向了key(7)</code>。但是此时的<code>key(7).next 已经指向了key(3)</code>,环形链表就这样出现了。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/HashMap05.jpg\" alt=\"\"><br>于是,当我们的线程一调用到,HashTable.get(11)时,悲剧就出现了——Infinite Loop。</p>\n<hr>\n<p>参考：<br><a href=\"http://coolshell.cn/articles/9606.html\">疫苗：Java HashMap的死循环</a><br><a href=\"http://ifeve.com/hashmap-infinite-loop/\">不正当使用HashMap导致cpu 100%的问题追究</a> </p>"},{"title":"IP初识","date":"2016-11-28T06:18:00.000Z","_content":"### 基本认识\n&emsp;最近一次接触ip是在我读《TCP/IP详解》时读到了，其实我感觉这些基础对理解整个互联网的结构都有一些很好的认识，在TCP/IP的协议簇中，首先简单的说一下在TCP中分层：  \n- 数据链路层:一般都是物理设备驱动程序和接口\n- 网络层:处理分组在网络中的活动，如分组选路。TCP/IP中,IP协议,ICMP协议,IGMP协议\n- 运输层:主要为应用程序提供端到端的通信，主要包括两种协议:TCP(高可靠的)、UDP(不可靠的，效率高的)\n- 应用层:负责处理特定的应用程序的细节\n![](http://ofa8x9gy9.bkt.clouddn.com/TCP:IP%E5%88%86%E5%B1%82.png)\n上图是我认为对TCP/IP分层的理解很好的一张图TCP/IP分层和传统的OSI分层不一样。OSI的7层是分的更加详细。对于TCP/IP的协议簇重点关注的还是网络层，运输层。  \n  <!-- more -->  \n  在TCP/IP中有一个分层的概念值得注意:  \n> 应用层关心的是应用程序的细节，而不是数据在网络中的传输活动。下三层对应用程序一无所知，但它们要处理所有的通信细节.IP协议是一种不可靠的网络层服务,它只是尽可能的快地把分组从源节点送到目的节点,并不提供任何可靠性的保证,但是IP得可靠服务可以由上层协议(TCP)来提供。\n\n### IP地址的分类\n &emsp;互联网上每个接口必须有一个唯一32位的Internet地址(IP地址),基本分类如下：  \n![](http://ofa8x9gy9.bkt.clouddn.com/%E4%BA%94%E7%B1%BB%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80.png)  \nIP地址是具有一定基本结构，一共有5类地址,每一类都包括:标志位、网络号、主机号。5类地址分为三种:单播地址(目的为单个主机,有:A、B、C)，广播地址(目的端为给定网络上的所有主机:D),多播地址(目的端为同一组内的所有主机:E)。  \n### IP路由选择\n&emsp;在一般的通信中，IP可以从TCP、UDP、ICMP、接受数据报(即本地生成的数据报)并进行发送，或者从一个网络接口接受数据报并进行转发。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到处理。如果数据报的目的不是这些地址，那么如果IP层被设置为路由器的功能，那么就对数据报进行转发，否则数据报就被丢弃。并且IP数据包的TTL(生命周期)为0，则该IP数据包就也会被抛弃。路由表中一般包含：目的IP地址，数据报传输的网络接口，下一跳的IP地址。  \n&emsp;IP路由选择是逐跳进行的。IP不知道到达任何目地的完整路径(除了与主机 直接相连的目的地)。所有的IP路由选择只为数据报传输提供下一站路由器的IP地址。它假定下一站路由器比发送数据报的主机更接近目的路由。如果IP数据报不能送达且来自本机那么一般会想生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。  \n基本过程:\n1. 如果ip数据包的TTL为0,则该IP数据报直接被丢弃\n2. 搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机,则将该包发向目标主机\n3. 搜索路由表，如果匹配主机失败，则匹配同子网的路由器，如果找到，则将该包发向路由器\n4. 搜索路由表，如果匹配同子网路由器失败，内匹配同网号路由器，如果找到，则将该包发向路由器\n5. 搜索路由表，如果以上都失败了，就搜索默认路由\n6. 如果都失败了，就直接丢弃\n### 子网寻址  \n&emsp;现在的所有主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是*把主机号在分成一个子网号和一个主机号*。这样做的原因就是应为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为16777214和65534个主机,但是事实上,在一个网络中一般安排不了这么多的主机。下图为B类子网划分的例子:\n![](http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E5%AF%BB%E5%9D%80.png)  \n上面是一个B类网络地址(140.252),在剩下的16位中，8为用于子网号,8为用于主机号,这样就允许254个子网,每个子网就可以有254台主机。  \n### IP的子网掩码  \n&emsp;由于除了IP地址外，主机还需要知道有那几位是子网号,那几位是主机号,这两个信息都是通过子网掩码来获得  \n![](http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png)  \n> ps:判断一个IP地址所属的类别，一般看IP地址的开头就行，不看子网掩码。一般0~127是A类,128~191是B类,192~223是C类，224~239是D类。  \n\n### ARP协议---地址解析协议\n&emsp;首先在以太网协议中的规定，同一局域网的一台主机要和另一台主机进行通信，必须知道目标主机的MAC地址。但是在TCP/IP协议中，网络层和传输层都只关心目标主机的IP地址.所以这个ARP协议就是IP和MAC的一种映射。  \n具体过程:当A:192.168.10.11向B：192.168.10.19发送数据时，主机A首先会在自己的ARP缓存表(IP-MAC地址的对应表)中寻找是否有目标的MAC，如果不存在，那么主机就向同一网段的网络发送一个ARP协议的广播包(谁知道192.168.10.19的MAC地址)，网络上其他主机并不会响应ARP的广播，只有主机B接受大这个广播才会向主机A做出回应。主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。同时ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。  ","source":"_posts/IP初识.md","raw":"---\ntitle: IP初识\ndate: 2016-11-28 14:18:00\ncategories: \n- TCP/IP\ntags:\n- ip\n---\n### 基本认识\n&emsp;最近一次接触ip是在我读《TCP/IP详解》时读到了，其实我感觉这些基础对理解整个互联网的结构都有一些很好的认识，在TCP/IP的协议簇中，首先简单的说一下在TCP中分层：  \n- 数据链路层:一般都是物理设备驱动程序和接口\n- 网络层:处理分组在网络中的活动，如分组选路。TCP/IP中,IP协议,ICMP协议,IGMP协议\n- 运输层:主要为应用程序提供端到端的通信，主要包括两种协议:TCP(高可靠的)、UDP(不可靠的，效率高的)\n- 应用层:负责处理特定的应用程序的细节\n![](http://ofa8x9gy9.bkt.clouddn.com/TCP:IP%E5%88%86%E5%B1%82.png)\n上图是我认为对TCP/IP分层的理解很好的一张图TCP/IP分层和传统的OSI分层不一样。OSI的7层是分的更加详细。对于TCP/IP的协议簇重点关注的还是网络层，运输层。  \n  <!-- more -->  \n  在TCP/IP中有一个分层的概念值得注意:  \n> 应用层关心的是应用程序的细节，而不是数据在网络中的传输活动。下三层对应用程序一无所知，但它们要处理所有的通信细节.IP协议是一种不可靠的网络层服务,它只是尽可能的快地把分组从源节点送到目的节点,并不提供任何可靠性的保证,但是IP得可靠服务可以由上层协议(TCP)来提供。\n\n### IP地址的分类\n &emsp;互联网上每个接口必须有一个唯一32位的Internet地址(IP地址),基本分类如下：  \n![](http://ofa8x9gy9.bkt.clouddn.com/%E4%BA%94%E7%B1%BB%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80.png)  \nIP地址是具有一定基本结构，一共有5类地址,每一类都包括:标志位、网络号、主机号。5类地址分为三种:单播地址(目的为单个主机,有:A、B、C)，广播地址(目的端为给定网络上的所有主机:D),多播地址(目的端为同一组内的所有主机:E)。  \n### IP路由选择\n&emsp;在一般的通信中，IP可以从TCP、UDP、ICMP、接受数据报(即本地生成的数据报)并进行发送，或者从一个网络接口接受数据报并进行转发。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到处理。如果数据报的目的不是这些地址，那么如果IP层被设置为路由器的功能，那么就对数据报进行转发，否则数据报就被丢弃。并且IP数据包的TTL(生命周期)为0，则该IP数据包就也会被抛弃。路由表中一般包含：目的IP地址，数据报传输的网络接口，下一跳的IP地址。  \n&emsp;IP路由选择是逐跳进行的。IP不知道到达任何目地的完整路径(除了与主机 直接相连的目的地)。所有的IP路由选择只为数据报传输提供下一站路由器的IP地址。它假定下一站路由器比发送数据报的主机更接近目的路由。如果IP数据报不能送达且来自本机那么一般会想生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。  \n基本过程:\n1. 如果ip数据包的TTL为0,则该IP数据报直接被丢弃\n2. 搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机,则将该包发向目标主机\n3. 搜索路由表，如果匹配主机失败，则匹配同子网的路由器，如果找到，则将该包发向路由器\n4. 搜索路由表，如果匹配同子网路由器失败，内匹配同网号路由器，如果找到，则将该包发向路由器\n5. 搜索路由表，如果以上都失败了，就搜索默认路由\n6. 如果都失败了，就直接丢弃\n### 子网寻址  \n&emsp;现在的所有主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是*把主机号在分成一个子网号和一个主机号*。这样做的原因就是应为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为16777214和65534个主机,但是事实上,在一个网络中一般安排不了这么多的主机。下图为B类子网划分的例子:\n![](http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E5%AF%BB%E5%9D%80.png)  \n上面是一个B类网络地址(140.252),在剩下的16位中，8为用于子网号,8为用于主机号,这样就允许254个子网,每个子网就可以有254台主机。  \n### IP的子网掩码  \n&emsp;由于除了IP地址外，主机还需要知道有那几位是子网号,那几位是主机号,这两个信息都是通过子网掩码来获得  \n![](http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png)  \n> ps:判断一个IP地址所属的类别，一般看IP地址的开头就行，不看子网掩码。一般0~127是A类,128~191是B类,192~223是C类，224~239是D类。  \n\n### ARP协议---地址解析协议\n&emsp;首先在以太网协议中的规定，同一局域网的一台主机要和另一台主机进行通信，必须知道目标主机的MAC地址。但是在TCP/IP协议中，网络层和传输层都只关心目标主机的IP地址.所以这个ARP协议就是IP和MAC的一种映射。  \n具体过程:当A:192.168.10.11向B：192.168.10.19发送数据时，主机A首先会在自己的ARP缓存表(IP-MAC地址的对应表)中寻找是否有目标的MAC，如果不存在，那么主机就向同一网段的网络发送一个ARP协议的广播包(谁知道192.168.10.19的MAC地址)，网络上其他主机并不会响应ARP的广播，只有主机B接受大这个广播才会向主机A做出回应。主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。同时ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。  ","slug":"IP初识","published":1,"updated":"2016-12-14T01:59:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2bt10003khik0ct23h6p","content":"<h3 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h3><p>&emsp;最近一次接触ip是在我读《TCP/IP详解》时读到了，其实我感觉这些基础对理解整个互联网的结构都有一些很好的认识，在TCP/IP的协议簇中，首先简单的说一下在TCP中分层：  </p>\n<ul>\n<li>数据链路层:一般都是物理设备驱动程序和接口</li>\n<li>网络层:处理分组在网络中的活动，如分组选路。TCP/IP中,IP协议,ICMP协议,IGMP协议</li>\n<li>运输层:主要为应用程序提供端到端的通信，主要包括两种协议:TCP(高可靠的)、UDP(不可靠的，效率高的)</li>\n<li>应用层:负责处理特定的应用程序的细节<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/TCP:IP%E5%88%86%E5%B1%82.png\" alt=\"\"><br>上图是我认为对TCP/IP分层的理解很好的一张图TCP/IP分层和传统的OSI分层不一样。OSI的7层是分的更加详细。对于TCP/IP的协议簇重点关注的还是网络层，运输层。  <a id=\"more\"></a>  \n在TCP/IP中有一个分层的概念值得注意:  <blockquote>\n<p>应用层关心的是应用程序的细节，而不是数据在网络中的传输活动。下三层对应用程序一无所知，但它们要处理所有的通信细节.IP协议是一种不可靠的网络层服务,它只是尽可能的快地把分组从源节点送到目的节点,并不提供任何可靠性的保证,但是IP得可靠服务可以由上层协议(TCP)来提供。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"IP地址的分类\"><a href=\"#IP地址的分类\" class=\"headerlink\" title=\"IP地址的分类\"></a>IP地址的分类</h3><p> &emsp;互联网上每个接口必须有一个唯一32位的Internet地址(IP地址),基本分类如下：<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E4%BA%94%E7%B1%BB%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80.png\" alt=\"\"><br>IP地址是具有一定基本结构，一共有5类地址,每一类都包括:标志位、网络号、主机号。5类地址分为三种:单播地址(目的为单个主机,有:A、B、C)，广播地址(目的端为给定网络上的所有主机:D),多播地址(目的端为同一组内的所有主机:E)。  </p>\n<h3 id=\"IP路由选择\"><a href=\"#IP路由选择\" class=\"headerlink\" title=\"IP路由选择\"></a>IP路由选择</h3><p>&emsp;在一般的通信中，IP可以从TCP、UDP、ICMP、接受数据报(即本地生成的数据报)并进行发送，或者从一个网络接口接受数据报并进行转发。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到处理。如果数据报的目的不是这些地址，那么如果IP层被设置为路由器的功能，那么就对数据报进行转发，否则数据报就被丢弃。并且IP数据包的TTL(生命周期)为0，则该IP数据包就也会被抛弃。路由表中一般包含：目的IP地址，数据报传输的网络接口，下一跳的IP地址。<br>&emsp;IP路由选择是逐跳进行的。IP不知道到达任何目地的完整路径(除了与主机 直接相连的目的地)。所有的IP路由选择只为数据报传输提供下一站路由器的IP地址。它假定下一站路由器比发送数据报的主机更接近目的路由。如果IP数据报不能送达且来自本机那么一般会想生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。<br>基本过程:</p>\n<ol>\n<li>如果ip数据包的TTL为0,则该IP数据报直接被丢弃</li>\n<li>搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机,则将该包发向目标主机</li>\n<li>搜索路由表，如果匹配主机失败，则匹配同子网的路由器，如果找到，则将该包发向路由器</li>\n<li>搜索路由表，如果匹配同子网路由器失败，内匹配同网号路由器，如果找到，则将该包发向路由器</li>\n<li>搜索路由表，如果以上都失败了，就搜索默认路由</li>\n<li>如果都失败了，就直接丢弃<h3 id=\"子网寻址\"><a href=\"#子网寻址\" class=\"headerlink\" title=\"子网寻址\"></a>子网寻址</h3>&emsp;现在的所有主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是<em>把主机号在分成一个子网号和一个主机号</em>。这样做的原因就是应为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为16777214和65534个主机,但是事实上,在一个网络中一般安排不了这么多的主机。下图为B类子网划分的例子:<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E5%AF%BB%E5%9D%80.png\" alt=\"\"><br>上面是一个B类网络地址(140.252),在剩下的16位中，8为用于子网号,8为用于主机号,这样就允许254个子网,每个子网就可以有254台主机。  <h3 id=\"IP的子网掩码\"><a href=\"#IP的子网掩码\" class=\"headerlink\" title=\"IP的子网掩码\"></a>IP的子网掩码</h3>&emsp;由于除了IP地址外，主机还需要知道有那几位是子网号,那几位是主机号,这两个信息都是通过子网掩码来获得<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png\" alt=\"\">  <blockquote>\n<p>ps:判断一个IP地址所属的类别，一般看IP地址的开头就行，不看子网掩码。一般0~127是A类,128~191是B类,192~223是C类，224~239是D类。  </p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"ARP协议—地址解析协议\"><a href=\"#ARP协议—地址解析协议\" class=\"headerlink\" title=\"ARP协议—地址解析协议\"></a>ARP协议—地址解析协议</h3><p>&emsp;首先在以太网协议中的规定，同一局域网的一台主机要和另一台主机进行通信，必须知道目标主机的MAC地址。但是在TCP/IP协议中，网络层和传输层都只关心目标主机的IP地址.所以这个ARP协议就是IP和MAC的一种映射。<br>具体过程:当A:192.168.10.11向B：192.168.10.19发送数据时，主机A首先会在自己的ARP缓存表(IP-MAC地址的对应表)中寻找是否有目标的MAC，如果不存在，那么主机就向同一网段的网络发送一个ARP协议的广播包(谁知道192.168.10.19的MAC地址)，网络上其他主机并不会响应ARP的广播，只有主机B接受大这个广播才会向主机A做出回应。主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。同时ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。  </p>\n","excerpt":"<h3 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h3><p>&emsp;最近一次接触ip是在我读《TCP/IP详解》时读到了，其实我感觉这些基础对理解整个互联网的结构都有一些很好的认识，在TCP/IP的协议簇中，首先简单的说一下在TCP中分层：  </p>\n<ul>\n<li>数据链路层:一般都是物理设备驱动程序和接口</li>\n<li>网络层:处理分组在网络中的活动，如分组选路。TCP/IP中,IP协议,ICMP协议,IGMP协议</li>\n<li>运输层:主要为应用程序提供端到端的通信，主要包括两种协议:TCP(高可靠的)、UDP(不可靠的，效率高的)</li>\n<li>应用层:负责处理特定的应用程序的细节<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/TCP:IP%E5%88%86%E5%B1%82.png\" alt=\"\"><br>上图是我认为对TCP/IP分层的理解很好的一张图TCP/IP分层和传统的OSI分层不一样。OSI的7层是分的更加详细。对于TCP/IP的协议簇重点关注的还是网络层，运输层。","more":"在TCP/IP中有一个分层的概念值得注意:  <blockquote>\n<p>应用层关心的是应用程序的细节，而不是数据在网络中的传输活动。下三层对应用程序一无所知，但它们要处理所有的通信细节.IP协议是一种不可靠的网络层服务,它只是尽可能的快地把分组从源节点送到目的节点,并不提供任何可靠性的保证,但是IP得可靠服务可以由上层协议(TCP)来提供。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"IP地址的分类\"><a href=\"#IP地址的分类\" class=\"headerlink\" title=\"IP地址的分类\"></a>IP地址的分类</h3><p> &emsp;互联网上每个接口必须有一个唯一32位的Internet地址(IP地址),基本分类如下：<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E4%BA%94%E7%B1%BB%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80.png\" alt=\"\"><br>IP地址是具有一定基本结构，一共有5类地址,每一类都包括:标志位、网络号、主机号。5类地址分为三种:单播地址(目的为单个主机,有:A、B、C)，广播地址(目的端为给定网络上的所有主机:D),多播地址(目的端为同一组内的所有主机:E)。  </p>\n<h3 id=\"IP路由选择\"><a href=\"#IP路由选择\" class=\"headerlink\" title=\"IP路由选择\"></a>IP路由选择</h3><p>&emsp;在一般的通信中，IP可以从TCP、UDP、ICMP、接受数据报(即本地生成的数据报)并进行发送，或者从一个网络接口接受数据报并进行转发。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到处理。如果数据报的目的不是这些地址，那么如果IP层被设置为路由器的功能，那么就对数据报进行转发，否则数据报就被丢弃。并且IP数据包的TTL(生命周期)为0，则该IP数据包就也会被抛弃。路由表中一般包含：目的IP地址，数据报传输的网络接口，下一跳的IP地址。<br>&emsp;IP路由选择是逐跳进行的。IP不知道到达任何目地的完整路径(除了与主机 直接相连的目的地)。所有的IP路由选择只为数据报传输提供下一站路由器的IP地址。它假定下一站路由器比发送数据报的主机更接近目的路由。如果IP数据报不能送达且来自本机那么一般会想生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。<br>基本过程:</p>\n<ol>\n<li>如果ip数据包的TTL为0,则该IP数据报直接被丢弃</li>\n<li>搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机,则将该包发向目标主机</li>\n<li>搜索路由表，如果匹配主机失败，则匹配同子网的路由器，如果找到，则将该包发向路由器</li>\n<li>搜索路由表，如果匹配同子网路由器失败，内匹配同网号路由器，如果找到，则将该包发向路由器</li>\n<li>搜索路由表，如果以上都失败了，就搜索默认路由</li>\n<li>如果都失败了，就直接丢弃<h3 id=\"子网寻址\"><a href=\"#子网寻址\" class=\"headerlink\" title=\"子网寻址\"></a>子网寻址</h3>&emsp;现在的所有主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是<em>把主机号在分成一个子网号和一个主机号</em>。这样做的原因就是应为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为16777214和65534个主机,但是事实上,在一个网络中一般安排不了这么多的主机。下图为B类子网划分的例子:<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E5%AF%BB%E5%9D%80.png\" alt=\"\"><br>上面是一个B类网络地址(140.252),在剩下的16位中，8为用于子网号,8为用于主机号,这样就允许254个子网,每个子网就可以有254台主机。  <h3 id=\"IP的子网掩码\"><a href=\"#IP的子网掩码\" class=\"headerlink\" title=\"IP的子网掩码\"></a>IP的子网掩码</h3>&emsp;由于除了IP地址外，主机还需要知道有那几位是子网号,那几位是主机号,这两个信息都是通过子网掩码来获得<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png\" alt=\"\">  <blockquote>\n<p>ps:判断一个IP地址所属的类别，一般看IP地址的开头就行，不看子网掩码。一般0~127是A类,128~191是B类,192~223是C类，224~239是D类。  </p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"ARP协议—地址解析协议\"><a href=\"#ARP协议—地址解析协议\" class=\"headerlink\" title=\"ARP协议—地址解析协议\"></a>ARP协议—地址解析协议</h3><p>&emsp;首先在以太网协议中的规定，同一局域网的一台主机要和另一台主机进行通信，必须知道目标主机的MAC地址。但是在TCP/IP协议中，网络层和传输层都只关心目标主机的IP地址.所以这个ARP协议就是IP和MAC的一种映射。<br>具体过程:当A:192.168.10.11向B：192.168.10.19发送数据时，主机A首先会在自己的ARP缓存表(IP-MAC地址的对应表)中寻找是否有目标的MAC，如果不存在，那么主机就向同一网段的网络发送一个ARP协议的广播包(谁知道192.168.10.19的MAC地址)，网络上其他主机并不会响应ARP的广播，只有主机B接受大这个广播才会向主机A做出回应。主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。同时ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。  </p>"},{"title":"ICMP协议和UDP协议","date":"2016-12-12T14:46:51.000Z","_content":"### ICMP网络控制报文协议\nICMP经常被认为是IP层的一个组成部分,它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（UDP,TCP）使用。ICMP报文是在IP数据报内部传输的。由于IP是不可靠的协议，不能保证IP数据报能够成功到达目的主机，无法进行差错控制。但是这些信息会由ICMP将错误信息封包，然后传递给主机，让主机有处理错误的机会。\n![](http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png)   \nICMP数据报由8bit的错误类型和8bit的代码（表示制定类型中的一个功能，如果只有一个功能，代码就置0）以及16bit的校验和组成，检验和字段覆盖整个ICMP报文。  \nICMP报文大致可以分为：差错报文和查询报文。因为对ICMP的差错报文需要做一些特殊响应，需要进行区分。比如在对差错报文进行响应的时候，永远不会产生另一个ICMP差错报文，防止不断的产生差错一直循环。同时一下几种情况也不会产生ICMP差错报文：\n1. ICMP差错报文不会产生\n2. 目的地址是广播地址或多播地址的IP数据报\n3. 作为链路层广播的数据报\n4. 不是IP分片的第一片\n5. 源地址不是单个主机的数据报  \n<!--more-->  \n\n![](http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%B7%AE%E9%94%99%E6%95%B0%E6%8D%AE%E6%8A%A5.png) \nICMP查询报文：\n1. ping查询 \n2. 子网掩码查询：用于无盘工作站在初始化自身的时候初始化子网掩码\n3. 时间戳查询：同步时间\n#### ICMP应用---ping  \nping是利用ICMP协议报来侦测另一个主机是否可达。  \n原理就是用类型码为0的ICMP发请求，收到请求的主机则用类型码为8的ICMP进行回应。ping程序用来计算间隔时间，并计算有多少个包被送达。  \n![](http://ofa8x9gy9.bkt.clouddn.com/ICMP-ping.png) \n ping给出来了传送的时间和TTL的数据。  \n ping还给我们一个看主机到目的主机陆游的机会。因为，ICMP的ping请求在经过路由器的时候，路由器会把自己的IP放到数据报中，而最后主机则会把这个ip列表复制到回应ICMP数据包发回给主机。但很重要的一点IP头所能记录的信息是非常有限。  这样就有了另一个充分利用TTL数据的应用Traceroute  \n#### ICMP应用---Traceroute  \nTraceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。  \nTraceroute基本原理原理：它收到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据报，而经过第一个的路由器收到数据报后，就会把TTL减1，这样TTL就会变为0.路由器就会抛弃数据报，并向主机发送目的主机不可达的ICMP数据报。然后主机就会发送TTL=2的数据报，如此往复直到到达目的主机。这样Traceroute就拿到了所有经过的路由器的IP。  \n### UDP协议  \n#### 基本认识  \nUDP是一个简单的面向数据报的传输层协议,UDP为网络层以上和应用层以下提供了一个简单的接口,传输方式\"Best Effort\"。UDP不用建立链接,它一旦把应用程序发给网络层的数据发送出去,就不保留备份。所以也就不提供超时重传，出错重传等功能。属于不可靠的协议。  \nUDP其实可以看做IP协议暴露在传输层的一个接口。传输层和网络层的区别在于:传输层是提供端到端的服务的。打个比方:小明(进程A)在M市要去寄一封信给在N市的小芳(进程B)，其中邮局就统一把很多的信，用车从M运到N市(网络层)。最后由邮递员(传输层)进行最后一步把小明的信送到小芳的家中。UDP可以看做IP协议在传输层的“傀儡”。  \nUDP的数据包分为头部和数据。UDP的数据报需要经过IP协议的封装，然后通过IP协议传输到目的电脑，随后拆封，并将信息送到相应端口的。  \n![](http://ofa8x9gy9.bkt.clouddn.com/UDP%E7%9A%84%E5%B0%81%E8%A3%85.png)  \n![](http://ofa8x9gy9.bkt.clouddn.com/UDP%E9%A6%96%E9%83%A8.png)   \n#### 校验和  \n这在UDP中是一个可选的选项，UDP校验和覆盖UDP协议头和数据，这和IP的校验和是不同的，IP协议的校验和只是覆盖IP数据头。UDP和TCP都包含一个伪首部，伪首部包含IP地址，目的是让UDP两次检查数据是否已经正确到达目的地，如果发送端没有打开检验和选项，而接收端计算检验和有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/ICMP协议和UDP协议.md","raw":"---\ntitle: ICMP协议和UDP协议\ndate: 2016-12-12 22:46:51\ncategories: \n- TCP/IP\ntags:\n- ICMP\n- UDP\n---\n### ICMP网络控制报文协议\nICMP经常被认为是IP层的一个组成部分,它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（UDP,TCP）使用。ICMP报文是在IP数据报内部传输的。由于IP是不可靠的协议，不能保证IP数据报能够成功到达目的主机，无法进行差错控制。但是这些信息会由ICMP将错误信息封包，然后传递给主机，让主机有处理错误的机会。\n![](http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png)   \nICMP数据报由8bit的错误类型和8bit的代码（表示制定类型中的一个功能，如果只有一个功能，代码就置0）以及16bit的校验和组成，检验和字段覆盖整个ICMP报文。  \nICMP报文大致可以分为：差错报文和查询报文。因为对ICMP的差错报文需要做一些特殊响应，需要进行区分。比如在对差错报文进行响应的时候，永远不会产生另一个ICMP差错报文，防止不断的产生差错一直循环。同时一下几种情况也不会产生ICMP差错报文：\n1. ICMP差错报文不会产生\n2. 目的地址是广播地址或多播地址的IP数据报\n3. 作为链路层广播的数据报\n4. 不是IP分片的第一片\n5. 源地址不是单个主机的数据报  \n<!--more-->  \n\n![](http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%B7%AE%E9%94%99%E6%95%B0%E6%8D%AE%E6%8A%A5.png) \nICMP查询报文：\n1. ping查询 \n2. 子网掩码查询：用于无盘工作站在初始化自身的时候初始化子网掩码\n3. 时间戳查询：同步时间\n#### ICMP应用---ping  \nping是利用ICMP协议报来侦测另一个主机是否可达。  \n原理就是用类型码为0的ICMP发请求，收到请求的主机则用类型码为8的ICMP进行回应。ping程序用来计算间隔时间，并计算有多少个包被送达。  \n![](http://ofa8x9gy9.bkt.clouddn.com/ICMP-ping.png) \n ping给出来了传送的时间和TTL的数据。  \n ping还给我们一个看主机到目的主机陆游的机会。因为，ICMP的ping请求在经过路由器的时候，路由器会把自己的IP放到数据报中，而最后主机则会把这个ip列表复制到回应ICMP数据包发回给主机。但很重要的一点IP头所能记录的信息是非常有限。  这样就有了另一个充分利用TTL数据的应用Traceroute  \n#### ICMP应用---Traceroute  \nTraceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。  \nTraceroute基本原理原理：它收到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据报，而经过第一个的路由器收到数据报后，就会把TTL减1，这样TTL就会变为0.路由器就会抛弃数据报，并向主机发送目的主机不可达的ICMP数据报。然后主机就会发送TTL=2的数据报，如此往复直到到达目的主机。这样Traceroute就拿到了所有经过的路由器的IP。  \n### UDP协议  \n#### 基本认识  \nUDP是一个简单的面向数据报的传输层协议,UDP为网络层以上和应用层以下提供了一个简单的接口,传输方式\"Best Effort\"。UDP不用建立链接,它一旦把应用程序发给网络层的数据发送出去,就不保留备份。所以也就不提供超时重传，出错重传等功能。属于不可靠的协议。  \nUDP其实可以看做IP协议暴露在传输层的一个接口。传输层和网络层的区别在于:传输层是提供端到端的服务的。打个比方:小明(进程A)在M市要去寄一封信给在N市的小芳(进程B)，其中邮局就统一把很多的信，用车从M运到N市(网络层)。最后由邮递员(传输层)进行最后一步把小明的信送到小芳的家中。UDP可以看做IP协议在传输层的“傀儡”。  \nUDP的数据包分为头部和数据。UDP的数据报需要经过IP协议的封装，然后通过IP协议传输到目的电脑，随后拆封，并将信息送到相应端口的。  \n![](http://ofa8x9gy9.bkt.clouddn.com/UDP%E7%9A%84%E5%B0%81%E8%A3%85.png)  \n![](http://ofa8x9gy9.bkt.clouddn.com/UDP%E9%A6%96%E9%83%A8.png)   \n#### 校验和  \n这在UDP中是一个可选的选项，UDP校验和覆盖UDP协议头和数据，这和IP的校验和是不同的，IP协议的校验和只是覆盖IP数据头。UDP和TCP都包含一个伪首部，伪首部包含IP地址，目的是让UDP两次检查数据是否已经正确到达目的地，如果发送端没有打开检验和选项，而接收端计算检验和有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"ICMP协议和UDP协议","published":1,"updated":"2016-12-29T07:18:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2bte0007khikrg5kivxx","content":"<h3 id=\"ICMP网络控制报文协议\"><a href=\"#ICMP网络控制报文协议\" class=\"headerlink\" title=\"ICMP网络控制报文协议\"></a>ICMP网络控制报文协议</h3><p>ICMP经常被认为是IP层的一个组成部分,它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（UDP,TCP）使用。ICMP报文是在IP数据报内部传输的。由于IP是不可靠的协议，不能保证IP数据报能够成功到达目的主机，无法进行差错控制。但是这些信息会由ICMP将错误信息封包，然后传递给主机，让主机有处理错误的机会。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png\" alt=\"\"><br>ICMP数据报由8bit的错误类型和8bit的代码（表示制定类型中的一个功能，如果只有一个功能，代码就置0）以及16bit的校验和组成，检验和字段覆盖整个ICMP报文。<br>ICMP报文大致可以分为：差错报文和查询报文。因为对ICMP的差错报文需要做一些特殊响应，需要进行区分。比如在对差错报文进行响应的时候，永远不会产生另一个ICMP差错报文，防止不断的产生差错一直循环。同时一下几种情况也不会产生ICMP差错报文：</p>\n<ol>\n<li>ICMP差错报文不会产生</li>\n<li>目的地址是广播地址或多播地址的IP数据报</li>\n<li>作为链路层广播的数据报</li>\n<li>不是IP分片的第一片</li>\n<li>源地址不是单个主机的数据报  <a id=\"more\"></a>  \n</li>\n</ol>\n<p><img src=\"http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%B7%AE%E9%94%99%E6%95%B0%E6%8D%AE%E6%8A%A5.png\" alt=\"\"><br>ICMP查询报文：</p>\n<ol>\n<li>ping查询 </li>\n<li>子网掩码查询：用于无盘工作站在初始化自身的时候初始化子网掩码</li>\n<li>时间戳查询：同步时间<h4 id=\"ICMP应用—ping\"><a href=\"#ICMP应用—ping\" class=\"headerlink\" title=\"ICMP应用—ping\"></a>ICMP应用—ping</h4>ping是利用ICMP协议报来侦测另一个主机是否可达。<br>原理就是用类型码为0的ICMP发请求，收到请求的主机则用类型码为8的ICMP进行回应。ping程序用来计算间隔时间，并计算有多少个包被送达。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/ICMP-ping.png\" alt=\"\"><br>ping给出来了传送的时间和TTL的数据。<br>ping还给我们一个看主机到目的主机陆游的机会。因为，ICMP的ping请求在经过路由器的时候，路由器会把自己的IP放到数据报中，而最后主机则会把这个ip列表复制到回应ICMP数据包发回给主机。但很重要的一点IP头所能记录的信息是非常有限。  这样就有了另一个充分利用TTL数据的应用Traceroute  <h4 id=\"ICMP应用—Traceroute\"><a href=\"#ICMP应用—Traceroute\" class=\"headerlink\" title=\"ICMP应用—Traceroute\"></a>ICMP应用—Traceroute</h4>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。<br>Traceroute基本原理原理：它收到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据报，而经过第一个的路由器收到数据报后，就会把TTL减1，这样TTL就会变为0.路由器就会抛弃数据报，并向主机发送目的主机不可达的ICMP数据报。然后主机就会发送TTL=2的数据报，如此往复直到到达目的主机。这样Traceroute就拿到了所有经过的路由器的IP。  <h3 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h3><h4 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h4>UDP是一个简单的面向数据报的传输层协议,UDP为网络层以上和应用层以下提供了一个简单的接口,传输方式”Best Effort”。UDP不用建立链接,它一旦把应用程序发给网络层的数据发送出去,就不保留备份。所以也就不提供超时重传，出错重传等功能。属于不可靠的协议。<br>UDP其实可以看做IP协议暴露在传输层的一个接口。传输层和网络层的区别在于:传输层是提供端到端的服务的。打个比方:小明(进程A)在M市要去寄一封信给在N市的小芳(进程B)，其中邮局就统一把很多的信，用车从M运到N市(网络层)。最后由邮递员(传输层)进行最后一步把小明的信送到小芳的家中。UDP可以看做IP协议在传输层的“傀儡”。<br>UDP的数据包分为头部和数据。UDP的数据报需要经过IP协议的封装，然后通过IP协议传输到目的电脑，随后拆封，并将信息送到相应端口的。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/UDP%E7%9A%84%E5%B0%81%E8%A3%85.png\" alt=\"\"><br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/UDP%E9%A6%96%E9%83%A8.png\" alt=\"\">   <h4 id=\"校验和\"><a href=\"#校验和\" class=\"headerlink\" title=\"校验和\"></a>校验和</h4>这在UDP中是一个可选的选项，UDP校验和覆盖UDP协议头和数据，这和IP的校验和是不同的，IP协议的校验和只是覆盖IP数据头。UDP和TCP都包含一个伪首部，伪首部包含IP地址，目的是让UDP两次检查数据是否已经正确到达目的地，如果发送端没有打开检验和选项，而接收端计算检验和有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文。</li>\n</ol>\n","excerpt":"<h3 id=\"ICMP网络控制报文协议\"><a href=\"#ICMP网络控制报文协议\" class=\"headerlink\" title=\"ICMP网络控制报文协议\"></a>ICMP网络控制报文协议</h3><p>ICMP经常被认为是IP层的一个组成部分,它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（UDP,TCP）使用。ICMP报文是在IP数据报内部传输的。由于IP是不可靠的协议，不能保证IP数据报能够成功到达目的主机，无法进行差错控制。但是这些信息会由ICMP将错误信息封包，然后传递给主机，让主机有处理错误的机会。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png\" alt=\"\"><br>ICMP数据报由8bit的错误类型和8bit的代码（表示制定类型中的一个功能，如果只有一个功能，代码就置0）以及16bit的校验和组成，检验和字段覆盖整个ICMP报文。<br>ICMP报文大致可以分为：差错报文和查询报文。因为对ICMP的差错报文需要做一些特殊响应，需要进行区分。比如在对差错报文进行响应的时候，永远不会产生另一个ICMP差错报文，防止不断的产生差错一直循环。同时一下几种情况也不会产生ICMP差错报文：</p>\n<ol>\n<li>ICMP差错报文不会产生</li>\n<li>目的地址是广播地址或多播地址的IP数据报</li>\n<li>作为链路层广播的数据报</li>\n<li>不是IP分片的第一片</li>\n<li>源地址不是单个主机的数据报","more":"</li>\n</ol>\n<p><img src=\"http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%B7%AE%E9%94%99%E6%95%B0%E6%8D%AE%E6%8A%A5.png\" alt=\"\"><br>ICMP查询报文：</p>\n<ol>\n<li>ping查询 </li>\n<li>子网掩码查询：用于无盘工作站在初始化自身的时候初始化子网掩码</li>\n<li>时间戳查询：同步时间<h4 id=\"ICMP应用—ping\"><a href=\"#ICMP应用—ping\" class=\"headerlink\" title=\"ICMP应用—ping\"></a>ICMP应用—ping</h4>ping是利用ICMP协议报来侦测另一个主机是否可达。<br>原理就是用类型码为0的ICMP发请求，收到请求的主机则用类型码为8的ICMP进行回应。ping程序用来计算间隔时间，并计算有多少个包被送达。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/ICMP-ping.png\" alt=\"\"><br>ping给出来了传送的时间和TTL的数据。<br>ping还给我们一个看主机到目的主机陆游的机会。因为，ICMP的ping请求在经过路由器的时候，路由器会把自己的IP放到数据报中，而最后主机则会把这个ip列表复制到回应ICMP数据包发回给主机。但很重要的一点IP头所能记录的信息是非常有限。  这样就有了另一个充分利用TTL数据的应用Traceroute  <h4 id=\"ICMP应用—Traceroute\"><a href=\"#ICMP应用—Traceroute\" class=\"headerlink\" title=\"ICMP应用—Traceroute\"></a>ICMP应用—Traceroute</h4>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。<br>Traceroute基本原理原理：它收到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据报，而经过第一个的路由器收到数据报后，就会把TTL减1，这样TTL就会变为0.路由器就会抛弃数据报，并向主机发送目的主机不可达的ICMP数据报。然后主机就会发送TTL=2的数据报，如此往复直到到达目的主机。这样Traceroute就拿到了所有经过的路由器的IP。  <h3 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h3><h4 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h4>UDP是一个简单的面向数据报的传输层协议,UDP为网络层以上和应用层以下提供了一个简单的接口,传输方式”Best Effort”。UDP不用建立链接,它一旦把应用程序发给网络层的数据发送出去,就不保留备份。所以也就不提供超时重传，出错重传等功能。属于不可靠的协议。<br>UDP其实可以看做IP协议暴露在传输层的一个接口。传输层和网络层的区别在于:传输层是提供端到端的服务的。打个比方:小明(进程A)在M市要去寄一封信给在N市的小芳(进程B)，其中邮局就统一把很多的信，用车从M运到N市(网络层)。最后由邮递员(传输层)进行最后一步把小明的信送到小芳的家中。UDP可以看做IP协议在传输层的“傀儡”。<br>UDP的数据包分为头部和数据。UDP的数据报需要经过IP协议的封装，然后通过IP协议传输到目的电脑，随后拆封，并将信息送到相应端口的。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/UDP%E7%9A%84%E5%B0%81%E8%A3%85.png\" alt=\"\"><br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/UDP%E9%A6%96%E9%83%A8.png\" alt=\"\">   <h4 id=\"校验和\"><a href=\"#校验和\" class=\"headerlink\" title=\"校验和\"></a>校验和</h4>这在UDP中是一个可选的选项，UDP校验和覆盖UDP协议头和数据，这和IP的校验和是不同的，IP协议的校验和只是覆盖IP数据头。UDP和TCP都包含一个伪首部，伪首部包含IP地址，目的是让UDP两次检查数据是否已经正确到达目的地，如果发送端没有打开检验和选项，而接收端计算检验和有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文。</li>\n</ol>"},{"title":"java内存模型的认识","date":"2017-01-03T10:45:10.000Z","_content":"","source":"_posts/java内存模型的认识.md","raw":"---\ntitle: java内存模型的认识\ndate: 2017-01-03 18:45:10\ncategories: \n- Java\ntags: \n- Java\n---\n","slug":"java内存模型的认识","published":1,"updated":"2017-01-05T09:23:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2bti0008khik0aov6wll","content":"","excerpt":"","more":""},{"title":"Java里的HashMap和golang里的map","date":"2016-12-05T06:29:56.000Z","_content":"### 哈希表  \n哈希表就是一种以`键-值(key-value)`存储数据的结构,我们只要输入待查找的键即Key,即可找到对应的值。  \n使用哈希找查有两个步骤:\n1. 使用哈希函数将被找查的键转换为数组的索引.在理想的情况下,不同的键会被装换为不同的索引值,但是在有些情况下我们需要处理多个键被哈希到同一个索引值得情况。所以哈希查找的第二个步骤是处理冲突。\n2. 处理哈希碰撞冲突。一般处理哈希碰撞用拉链法和开放寻址法等方法。\n> 开放地址法:当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。  \n> 拉链法:当通过哈希函数把键转换为数组的索引时,如果索引重复,就在该位置用链表顺序 存储该键值对。  \n\n![](http://ofa8x9gy9.bkt.clouddn.com/%E6%8B%89%E9%93%BE%E6%B3%95.png)  \n### Java中的HashMap  \n基本认识：基于Map接口,*允许null键/值,非同步,不保证有序*,也不保证顺序不随时间变化。  \nHashMap中和Map一样，键值对都是保存在一个内部类中的,而在HashMap类中有一个很重要的字段，那就是Node[] table，即是一个哈希桶数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。  \n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;    //用来定位数组索引位置\n        final K key;\n        V value;\n        Node<K,V> next;   //链表的下一个node\n\n        Node(int hash, K key, V value, Node<K,V> next) { ... }\n       /.../\n}\n```\n<!--more--> \n还有两个重要参数:  \n* 容量(Capacity)：Capacity就是bucket的大小\n* 负载因子(Load factor)：Load factor就是bucket填满程度的最大比例。 \n如果对迭代性能要求很高的话不要把`capacity`设置过大,也不要吧`load factor`设置过小，当bucket的entries的数目大于`capacity*load factor`是就需要调整bucket的大小为当前的2倍。\n#### `put()`函数的基本思路:\n1. 对key的`hashCode()`做hash,然后计算对应的index\n2. 如果没有发生碰撞就直接放到桶里\n3. 如果发生碰撞就采用拉链法,以链表的形式存储在该桶里\n4. 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD),就把链表转换为红黑树\n5. 如果节点存在,就替换成新的value\n6. 如果桶满了(超过load factor*current capacity),就要resize  \n\n```java\npublic V put(K key, V value){\n\treturn putVal(hash(key),key,value,false,true);\n}\nfinal V putVal(int hash,K key,V value,boolean onlyIfAbsent,boolean evict)\n{\nNode<K,V>[] tab; Node<K,V> p; int n, i;\n    // tab为空则创建\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 计算index，并对null做处理\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        // 节点存在\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 该链为树\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 该链为链表\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        // 写入\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 超过load factor*current capacity，resize\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n#### `get()`函数的基本思路\n1. 桶里的第一个节点就直接命中\n2. 如果桶里有冲突，就通过`equal()`来找查对应的entry，若为树时间复杂度为O(logN)，链表就是O(N)   \n\n```java\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            // 直接命中\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            // 未命中\n            if ((e = first.next) != null) {\n                // 在树中get\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                // 在链表中get\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n}\n```\n注意:通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将`K/V`传给put方法时,它调用hashCode计算hash从而得到bucket位置,进一步存储，`HashMap`会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时,我们将K传给get,它调用hashCode计算hash从而得到bucket位置,并进一步调用equals()方法确定键值对。如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来,在Java 8中,如果一个bucket中碰撞冲突的元素超过某个限制(默认是8,则使用红黑树来替换链表,从而提高速度 \n\n### golang中的map  \n基本认识:在go中一个map就是一个哈希表的引用,map类型可以写为map[K]V,对K的类型要求是必须支持`==`比较运算符。但是不建议使用浮点型作为Key。\n\n```go\nstruct Hmap{//map的关键数据\n    uint8   B;    // 可以容纳2^B个项\n    uint16  bucketsize;   // 每个桶的大小\n    ....\n    byte    *buckets;     // 2^B个Buckets的数组\n    byte    *oldbuckets;  // 前一个buckets，只有当正在扩容时才不为空\n};\n//初始化的3种方式\nages:=make(map[string]int)// mapping from strings to ints\nages:=map[string]int{}\nages:=map[string]int{\n    \"alice\":0,\n    \"charlie\":33,\n}\n//取值\nages[\"alice\"]=0\n//赋值\nages[\"charlie\"]=34\n//删除\ndelete(ages, \"alice\") // remove element ages[\"alice\"]\n```\n\n上面这些都是安全的，及时失败也会返回对应value类型的零值。  \n但是有时候需要想知道对应的元素是否真的在map之中。推荐写法：\n\n```go\n//map的下标语法将产生两个值；第二个是一个布尔值   \n//用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。\nif age, ok := ages[\"alice\"]; !ok { /* ... */ }\n```\n\n#### 扩容\n在golang中主要采用增量扩容--扩容因子为`6.5`。这个主要是为了缩短map容器的响应时间，因为在map桶里面数据很多事,直接复制进行扩容就会很卡，导致较长一段时间无法响应请求。不过具体时间复杂度还是采用的均摊法。具体做法:\n> 扩容会建立一个大小是原来2倍的空表。将旧的bucket搬到新表中(复制),但是并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。\n   \n由于整个过程是逐渐完成的,这样就会导致一部分数据还没有完全复制到新表，所以会对insert，remove，get等操作产生影响。并且只有当所有复制操作完成后才会释放oldbucket。  \n\n#### `insert`分析基本思路  \n1. 根据key算出hash值，进而得出索引的位置\n2. 如果bucket的位置在old table中，就重新hash到新表中\n3. 查找对应的位置，如果在bucket中如果已经存在相应的key，就覆盖原来value，没有就插入\n4. 根据table中元素的个数，判断是否扩容\n5. 如果对应的bucket已经full，重新申请新的bucket作为overbucket(溢出桶链表)。\n6. 将key/value pair插入到bucket中。  \n\n#### `get`查找过程\n1. 根据key算出hash值，进而得出索引的位置\n2. 如果存在old table, 首先在old table中查找，如果找到的bucket已经扩容，转到步骤3。 反之，返回其对应的value。\n3. 在new table中查找对应的value。  \n\n```go\ndo { //对每个bucket\n    //依次比较桶内的每一项存放的高位hash与所求的hash值高位是否相等\n    for(i = 0, k = b->data, v = k + h->keysize * BUCKETSIZE; i < BUCKETSIZE; i++, k += h->keysize, v += h->valuesize) {\n        if(b->tophash[i] == top) { \n            k2 = IK(h, k);\n            t->key->alg->equal(&eq, t->key->size, key, k2);\n            if(eq) { //相等的情况下再去做key比较...\n                *keyp = k2;\n                return IV(h, v);\n            }\n        }\n    }\n    b = b->overflow; //b设置为它的下一下溢出链\n} while(b != nil);\n```\n\n这里一个细节需要注意一下。不认真看可能会以为低位用于定位bucket在数组的index，那么高位就是用于key/valule在bucket内部的offset。事实上高8位不是用作offset的，而是用于加快key的比较的。  \n#### 总结\n在扩容过程中，oldbucket是被冻结的，查找时会在oldbucket中查找，但不会在oldbucket中插入数据。如果在oldbucket是找到了相应的key，做法是将它迁移到新bucket后加入扩容标记。\n然后就是只要在某个bucket中找到第一个空位，就会将key/value插入到这个位置。也就是位置位于bucket前面的会覆盖后面的(类似于存储系统设计中做删除时的常用的技巧之一，直接用新数据追加方式写，新版本数据覆盖老版本数据)。找到了相同的key或者找到第一个空位就可以结束遍历了。不过这也意味着做删除时必须完全的遍历bucket所有溢出链，将所有的相同key数据都删除。所以目前map的设计是为插入而优化的，删除效率会比插入低一些。  \n\n---\n参考:  \n[Java 8系列之重新认识HashMap](http://tech.meituan.com/java-hashmap.html)  \n[Java HashMap工作原理及实现](http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/)","source":"_posts/Java里的hasMap和golang里的map.md","raw":"---\ntitle: Java里的HashMap和golang里的map\ndate: 2016-12-05 14:29:56\ncategories: \n- Java和golang\ntags: \n- golang\n- Java\n---\n### 哈希表  \n哈希表就是一种以`键-值(key-value)`存储数据的结构,我们只要输入待查找的键即Key,即可找到对应的值。  \n使用哈希找查有两个步骤:\n1. 使用哈希函数将被找查的键转换为数组的索引.在理想的情况下,不同的键会被装换为不同的索引值,但是在有些情况下我们需要处理多个键被哈希到同一个索引值得情况。所以哈希查找的第二个步骤是处理冲突。\n2. 处理哈希碰撞冲突。一般处理哈希碰撞用拉链法和开放寻址法等方法。\n> 开放地址法:当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。  \n> 拉链法:当通过哈希函数把键转换为数组的索引时,如果索引重复,就在该位置用链表顺序 存储该键值对。  \n\n![](http://ofa8x9gy9.bkt.clouddn.com/%E6%8B%89%E9%93%BE%E6%B3%95.png)  \n### Java中的HashMap  \n基本认识：基于Map接口,*允许null键/值,非同步,不保证有序*,也不保证顺序不随时间变化。  \nHashMap中和Map一样，键值对都是保存在一个内部类中的,而在HashMap类中有一个很重要的字段，那就是Node[] table，即是一个哈希桶数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。  \n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;    //用来定位数组索引位置\n        final K key;\n        V value;\n        Node<K,V> next;   //链表的下一个node\n\n        Node(int hash, K key, V value, Node<K,V> next) { ... }\n       /.../\n}\n```\n<!--more--> \n还有两个重要参数:  \n* 容量(Capacity)：Capacity就是bucket的大小\n* 负载因子(Load factor)：Load factor就是bucket填满程度的最大比例。 \n如果对迭代性能要求很高的话不要把`capacity`设置过大,也不要吧`load factor`设置过小，当bucket的entries的数目大于`capacity*load factor`是就需要调整bucket的大小为当前的2倍。\n#### `put()`函数的基本思路:\n1. 对key的`hashCode()`做hash,然后计算对应的index\n2. 如果没有发生碰撞就直接放到桶里\n3. 如果发生碰撞就采用拉链法,以链表的形式存储在该桶里\n4. 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD),就把链表转换为红黑树\n5. 如果节点存在,就替换成新的value\n6. 如果桶满了(超过load factor*current capacity),就要resize  \n\n```java\npublic V put(K key, V value){\n\treturn putVal(hash(key),key,value,false,true);\n}\nfinal V putVal(int hash,K key,V value,boolean onlyIfAbsent,boolean evict)\n{\nNode<K,V>[] tab; Node<K,V> p; int n, i;\n    // tab为空则创建\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 计算index，并对null做处理\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        // 节点存在\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 该链为树\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 该链为链表\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        // 写入\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 超过load factor*current capacity，resize\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n#### `get()`函数的基本思路\n1. 桶里的第一个节点就直接命中\n2. 如果桶里有冲突，就通过`equal()`来找查对应的entry，若为树时间复杂度为O(logN)，链表就是O(N)   \n\n```java\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            // 直接命中\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            // 未命中\n            if ((e = first.next) != null) {\n                // 在树中get\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                // 在链表中get\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n}\n```\n注意:通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将`K/V`传给put方法时,它调用hashCode计算hash从而得到bucket位置,进一步存储，`HashMap`会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时,我们将K传给get,它调用hashCode计算hash从而得到bucket位置,并进一步调用equals()方法确定键值对。如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来,在Java 8中,如果一个bucket中碰撞冲突的元素超过某个限制(默认是8,则使用红黑树来替换链表,从而提高速度 \n\n### golang中的map  \n基本认识:在go中一个map就是一个哈希表的引用,map类型可以写为map[K]V,对K的类型要求是必须支持`==`比较运算符。但是不建议使用浮点型作为Key。\n\n```go\nstruct Hmap{//map的关键数据\n    uint8   B;    // 可以容纳2^B个项\n    uint16  bucketsize;   // 每个桶的大小\n    ....\n    byte    *buckets;     // 2^B个Buckets的数组\n    byte    *oldbuckets;  // 前一个buckets，只有当正在扩容时才不为空\n};\n//初始化的3种方式\nages:=make(map[string]int)// mapping from strings to ints\nages:=map[string]int{}\nages:=map[string]int{\n    \"alice\":0,\n    \"charlie\":33,\n}\n//取值\nages[\"alice\"]=0\n//赋值\nages[\"charlie\"]=34\n//删除\ndelete(ages, \"alice\") // remove element ages[\"alice\"]\n```\n\n上面这些都是安全的，及时失败也会返回对应value类型的零值。  \n但是有时候需要想知道对应的元素是否真的在map之中。推荐写法：\n\n```go\n//map的下标语法将产生两个值；第二个是一个布尔值   \n//用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。\nif age, ok := ages[\"alice\"]; !ok { /* ... */ }\n```\n\n#### 扩容\n在golang中主要采用增量扩容--扩容因子为`6.5`。这个主要是为了缩短map容器的响应时间，因为在map桶里面数据很多事,直接复制进行扩容就会很卡，导致较长一段时间无法响应请求。不过具体时间复杂度还是采用的均摊法。具体做法:\n> 扩容会建立一个大小是原来2倍的空表。将旧的bucket搬到新表中(复制),但是并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。\n   \n由于整个过程是逐渐完成的,这样就会导致一部分数据还没有完全复制到新表，所以会对insert，remove，get等操作产生影响。并且只有当所有复制操作完成后才会释放oldbucket。  \n\n#### `insert`分析基本思路  \n1. 根据key算出hash值，进而得出索引的位置\n2. 如果bucket的位置在old table中，就重新hash到新表中\n3. 查找对应的位置，如果在bucket中如果已经存在相应的key，就覆盖原来value，没有就插入\n4. 根据table中元素的个数，判断是否扩容\n5. 如果对应的bucket已经full，重新申请新的bucket作为overbucket(溢出桶链表)。\n6. 将key/value pair插入到bucket中。  \n\n#### `get`查找过程\n1. 根据key算出hash值，进而得出索引的位置\n2. 如果存在old table, 首先在old table中查找，如果找到的bucket已经扩容，转到步骤3。 反之，返回其对应的value。\n3. 在new table中查找对应的value。  \n\n```go\ndo { //对每个bucket\n    //依次比较桶内的每一项存放的高位hash与所求的hash值高位是否相等\n    for(i = 0, k = b->data, v = k + h->keysize * BUCKETSIZE; i < BUCKETSIZE; i++, k += h->keysize, v += h->valuesize) {\n        if(b->tophash[i] == top) { \n            k2 = IK(h, k);\n            t->key->alg->equal(&eq, t->key->size, key, k2);\n            if(eq) { //相等的情况下再去做key比较...\n                *keyp = k2;\n                return IV(h, v);\n            }\n        }\n    }\n    b = b->overflow; //b设置为它的下一下溢出链\n} while(b != nil);\n```\n\n这里一个细节需要注意一下。不认真看可能会以为低位用于定位bucket在数组的index，那么高位就是用于key/valule在bucket内部的offset。事实上高8位不是用作offset的，而是用于加快key的比较的。  \n#### 总结\n在扩容过程中，oldbucket是被冻结的，查找时会在oldbucket中查找，但不会在oldbucket中插入数据。如果在oldbucket是找到了相应的key，做法是将它迁移到新bucket后加入扩容标记。\n然后就是只要在某个bucket中找到第一个空位，就会将key/value插入到这个位置。也就是位置位于bucket前面的会覆盖后面的(类似于存储系统设计中做删除时的常用的技巧之一，直接用新数据追加方式写，新版本数据覆盖老版本数据)。找到了相同的key或者找到第一个空位就可以结束遍历了。不过这也意味着做删除时必须完全的遍历bucket所有溢出链，将所有的相同key数据都删除。所以目前map的设计是为插入而优化的，删除效率会比插入低一些。  \n\n---\n参考:  \n[Java 8系列之重新认识HashMap](http://tech.meituan.com/java-hashmap.html)  \n[Java HashMap工作原理及实现](http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/)","slug":"Java里的hasMap和golang里的map","published":1,"updated":"2016-12-22T06:24:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2btn0009khiki5j2pct3","content":"<h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>哈希表就是一种以<code>键-值(key-value)</code>存储数据的结构,我们只要输入待查找的键即Key,即可找到对应的值。<br>使用哈希找查有两个步骤:</p>\n<ol>\n<li>使用哈希函数将被找查的键转换为数组的索引.在理想的情况下,不同的键会被装换为不同的索引值,但是在有些情况下我们需要处理多个键被哈希到同一个索引值得情况。所以哈希查找的第二个步骤是处理冲突。</li>\n<li>处理哈希碰撞冲突。一般处理哈希碰撞用拉链法和开放寻址法等方法。<blockquote>\n<p>开放地址法:当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。<br>拉链法:当通过哈希函数把键转换为数组的索引时,如果索引重复,就在该位置用链表顺序 存储该键值对。  </p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E6%8B%89%E9%93%BE%E6%B3%95.png\" alt=\"\">  </p>\n<h3 id=\"Java中的HashMap\"><a href=\"#Java中的HashMap\" class=\"headerlink\" title=\"Java中的HashMap\"></a>Java中的HashMap</h3><p>基本认识：基于Map接口,<em>允许null键/值,非同步,不保证有序</em>,也不保证顺序不随时间变化。<br>HashMap中和Map一样，键值对都是保存在一个内部类中的,而在HashMap类中有一个很重要的字段，那就是Node[] table，即是一个哈希桶数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;    <span class=\"comment\">//用来定位数组索引位置</span></div><div class=\"line\">        <span class=\"keyword\">final</span> K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        Node&lt;K,V&gt; next;   <span class=\"comment\">//链表的下一个node</span></div><div class=\"line\"></div><div class=\"line\">        Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class=\"line\">       /.../</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a> \n<p>还有两个重要参数:  </p>\n<ul>\n<li>容量(Capacity)：Capacity就是bucket的大小</li>\n<li>负载因子(Load factor)：Load factor就是bucket填满程度的最大比例。<br>如果对迭代性能要求很高的话不要把<code>capacity</code>设置过大,也不要吧<code>load factor</code>设置过小，当bucket的entries的数目大于<code>capacity*load factor</code>是就需要调整bucket的大小为当前的2倍。<h4 id=\"put-函数的基本思路\"><a href=\"#put-函数的基本思路\" class=\"headerlink\" title=\"put()函数的基本思路:\"></a><code>put()</code>函数的基本思路:</h4></li>\n</ul>\n<ol>\n<li>对key的<code>hashCode()</code>做hash,然后计算对应的index</li>\n<li>如果没有发生碰撞就直接放到桶里</li>\n<li>如果发生碰撞就采用拉链法,以链表的形式存储在该桶里</li>\n<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD),就把链表转换为红黑树</li>\n<li>如果节点存在,就替换成新的value</li>\n<li>如果桶满了(超过load factor*current capacity),就要resize  </li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> putVal(hash(key),key,value,<span class=\"keyword\">false</span>,<span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash,K key,V value,<span class=\"keyword\">boolean</span> onlyIfAbsent,<span class=\"keyword\">boolean</span> evict)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</div><div class=\"line\">    <span class=\"comment\">// tab为空则创建</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</div><div class=\"line\">        n = (tab = resize()).length;</div><div class=\"line\">    <span class=\"comment\">// 计算index，并对null做处理</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</div><div class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        Node&lt;K,V&gt; e; K k;</div><div class=\"line\">        <span class=\"comment\">// 节点存在</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</div><div class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">            e = p;</div><div class=\"line\">        <span class=\"comment\">// 该链为树</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</div><div class=\"line\">        <span class=\"comment\">// 该链为链表</span></div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></div><div class=\"line\">                        treeifyBin(tab, hash);</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                p = e;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 写入</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></div><div class=\"line\">            V oldValue = e.value;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</div><div class=\"line\">                e.value = value;</div><div class=\"line\">            afterNodeAccess(e);</div><div class=\"line\">            <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ++modCount;</div><div class=\"line\">    <span class=\"comment\">// 超过load factor*current capacity，resize</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</div><div class=\"line\">        resize();</div><div class=\"line\">    afterNodeInsertion(evict);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"get-函数的基本思路\"><a href=\"#get-函数的基本思路\" class=\"headerlink\" title=\"get()函数的基本思路\"></a><code>get()</code>函数的基本思路</h4><ol>\n<li>桶里的第一个节点就直接命中</li>\n<li>如果桶里有冲突，就通过<code>equal()</code>来找查对应的entry，若为树时间复杂度为O(logN)，链表就是O(N)   </li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">        Node&lt;K,V&gt; e;</div><div class=\"line\">        <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</div><div class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</div><div class=\"line\">            (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 直接命中</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></div><div class=\"line\">                ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                <span class=\"keyword\">return</span> first;</div><div class=\"line\">            <span class=\"comment\">// 未命中</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 在树中get</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                    <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class=\"line\">                <span class=\"comment\">// 在链表中get</span></div><div class=\"line\">                <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                        <span class=\"keyword\">return</span> e;</div><div class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意:通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将<code>K/V</code>传给put方法时,它调用hashCode计算hash从而得到bucket位置,进一步存储，<code>HashMap</code>会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时,我们将K传给get,它调用hashCode计算hash从而得到bucket位置,并进一步调用equals()方法确定键值对。如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来,在Java 8中,如果一个bucket中碰撞冲突的元素超过某个限制(默认是8,则使用红黑树来替换链表,从而提高速度 </p>\n<h3 id=\"golang中的map\"><a href=\"#golang中的map\" class=\"headerlink\" title=\"golang中的map\"></a>golang中的map</h3><p>基本认识:在go中一个map就是一个哈希表的引用,map类型可以写为map[K]V,对K的类型要求是必须支持<code>==</code>比较运算符。但是不建议使用浮点型作为Key。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Hmap&#123;<span class=\"comment\">//map的关键数据</span></div><div class=\"line\">    <span class=\"keyword\">uint8</span>   B;    <span class=\"comment\">// 可以容纳2^B个项</span></div><div class=\"line\">    <span class=\"keyword\">uint16</span>  bucketsize;   <span class=\"comment\">// 每个桶的大小</span></div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"keyword\">byte</span>    *buckets;     <span class=\"comment\">// 2^B个Buckets的数组</span></div><div class=\"line\">    <span class=\"keyword\">byte</span>    *oldbuckets;  <span class=\"comment\">// 前一个buckets，只有当正在扩容时才不为空</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//初始化的3种方式</span></div><div class=\"line\">ages:=<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)<span class=\"comment\">// mapping from strings to ints</span></div><div class=\"line\">ages:=<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>&#123;&#125;</div><div class=\"line\">ages:=<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>&#123;</div><div class=\"line\">    <span class=\"string\">\"alice\"</span>:<span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"string\">\"charlie\"</span>:<span class=\"number\">33</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//取值</span></div><div class=\"line\">ages[<span class=\"string\">\"alice\"</span>]=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">//赋值</span></div><div class=\"line\">ages[<span class=\"string\">\"charlie\"</span>]=<span class=\"number\">34</span></div><div class=\"line\"><span class=\"comment\">//删除</span></div><div class=\"line\"><span class=\"built_in\">delete</span>(ages, <span class=\"string\">\"alice\"</span>) <span class=\"comment\">// remove element ages[\"alice\"]</span></div></pre></td></tr></table></figure>\n<p>上面这些都是安全的，及时失败也会返回对应value类型的零值。<br>但是有时候需要想知道对应的元素是否真的在map之中。推荐写法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//map的下标语法将产生两个值；第二个是一个布尔值   </span></div><div class=\"line\"><span class=\"comment\">//用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。</span></div><div class=\"line\"><span class=\"keyword\">if</span> age, ok := ages[<span class=\"string\">\"alice\"</span>]; !ok &#123; <span class=\"comment\">/* ... */</span> &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h4><p>在golang中主要采用增量扩容–扩容因子为<code>6.5</code>。这个主要是为了缩短map容器的响应时间，因为在map桶里面数据很多事,直接复制进行扩容就会很卡，导致较长一段时间无法响应请求。不过具体时间复杂度还是采用的均摊法。具体做法:</p>\n<blockquote>\n<p>扩容会建立一个大小是原来2倍的空表。将旧的bucket搬到新表中(复制),但是并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。</p>\n</blockquote>\n<p>由于整个过程是逐渐完成的,这样就会导致一部分数据还没有完全复制到新表，所以会对insert，remove，get等操作产生影响。并且只有当所有复制操作完成后才会释放oldbucket。  </p>\n<h4 id=\"insert分析基本思路\"><a href=\"#insert分析基本思路\" class=\"headerlink\" title=\"insert分析基本思路\"></a><code>insert</code>分析基本思路</h4><ol>\n<li>根据key算出hash值，进而得出索引的位置</li>\n<li>如果bucket的位置在old table中，就重新hash到新表中</li>\n<li>查找对应的位置，如果在bucket中如果已经存在相应的key，就覆盖原来value，没有就插入</li>\n<li>根据table中元素的个数，判断是否扩容</li>\n<li>如果对应的bucket已经full，重新申请新的bucket作为overbucket(溢出桶链表)。</li>\n<li>将key/value pair插入到bucket中。  </li>\n</ol>\n<h4 id=\"get查找过程\"><a href=\"#get查找过程\" class=\"headerlink\" title=\"get查找过程\"></a><code>get</code>查找过程</h4><ol>\n<li>根据key算出hash值，进而得出索引的位置</li>\n<li>如果存在old table, 首先在old table中查找，如果找到的bucket已经扩容，转到步骤3。 反之，返回其对应的value。</li>\n<li>在new table中查找对应的value。  </li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">do &#123; <span class=\"comment\">//对每个bucket</span></div><div class=\"line\">    <span class=\"comment\">//依次比较桶内的每一项存放的高位hash与所求的hash值高位是否相等</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>, k = b-&gt;data, v = k + h-&gt;keysize * BUCKETSIZE; i &lt; BUCKETSIZE; i++, k += h-&gt;keysize, v += h-&gt;valuesize) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(b-&gt;tophash[i] == top) &#123; </div><div class=\"line\">            k2 = IK(h, k);</div><div class=\"line\">            t-&gt;key-&gt;alg-&gt;equal(&amp;eq, t-&gt;key-&gt;size, key, k2);</div><div class=\"line\">            <span class=\"keyword\">if</span>(eq) &#123; <span class=\"comment\">//相等的情况下再去做key比较...</span></div><div class=\"line\">                *keyp = k2;</div><div class=\"line\">                <span class=\"keyword\">return</span> IV(h, v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    b = b-&gt;overflow; <span class=\"comment\">//b设置为它的下一下溢出链</span></div><div class=\"line\">&#125; while(b != <span class=\"literal\">nil</span>);</div></pre></td></tr></table></figure>\n<p>这里一个细节需要注意一下。不认真看可能会以为低位用于定位bucket在数组的index，那么高位就是用于key/valule在bucket内部的offset。事实上高8位不是用作offset的，而是用于加快key的比较的。  </p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在扩容过程中，oldbucket是被冻结的，查找时会在oldbucket中查找，但不会在oldbucket中插入数据。如果在oldbucket是找到了相应的key，做法是将它迁移到新bucket后加入扩容标记。<br>然后就是只要在某个bucket中找到第一个空位，就会将key/value插入到这个位置。也就是位置位于bucket前面的会覆盖后面的(类似于存储系统设计中做删除时的常用的技巧之一，直接用新数据追加方式写，新版本数据覆盖老版本数据)。找到了相同的key或者找到第一个空位就可以结束遍历了。不过这也意味着做删除时必须完全的遍历bucket所有溢出链，将所有的相同key数据都删除。所以目前map的设计是为插入而优化的，删除效率会比插入低一些。  </p>\n<hr>\n<p>参考:<br><a href=\"http://tech.meituan.com/java-hashmap.html\" target=\"_blank\" rel=\"external\">Java 8系列之重新认识HashMap</a><br><a href=\"http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"external\">Java HashMap工作原理及实现</a></p>\n","excerpt":"<h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>哈希表就是一种以<code>键-值(key-value)</code>存储数据的结构,我们只要输入待查找的键即Key,即可找到对应的值。<br>使用哈希找查有两个步骤:</p>\n<ol>\n<li>使用哈希函数将被找查的键转换为数组的索引.在理想的情况下,不同的键会被装换为不同的索引值,但是在有些情况下我们需要处理多个键被哈希到同一个索引值得情况。所以哈希查找的第二个步骤是处理冲突。</li>\n<li>处理哈希碰撞冲突。一般处理哈希碰撞用拉链法和开放寻址法等方法。<blockquote>\n<p>开放地址法:当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。<br>拉链法:当通过哈希函数把键转换为数组的索引时,如果索引重复,就在该位置用链表顺序 存储该键值对。  </p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E6%8B%89%E9%93%BE%E6%B3%95.png\" alt=\"\">  </p>\n<h3 id=\"Java中的HashMap\"><a href=\"#Java中的HashMap\" class=\"headerlink\" title=\"Java中的HashMap\"></a>Java中的HashMap</h3><p>基本认识：基于Map接口,<em>允许null键/值,非同步,不保证有序</em>,也不保证顺序不随时间变化。<br>HashMap中和Map一样，键值对都是保存在一个内部类中的,而在HashMap类中有一个很重要的字段，那就是Node[] table，即是一个哈希桶数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;    <span class=\"comment\">//用来定位数组索引位置</span></div><div class=\"line\">        <span class=\"keyword\">final</span> K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        Node&lt;K,V&gt; next;   <span class=\"comment\">//链表的下一个node</span></div><div class=\"line\"></div><div class=\"line\">        Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class=\"line\">       /.../</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>还有两个重要参数:  </p>\n<ul>\n<li>容量(Capacity)：Capacity就是bucket的大小</li>\n<li>负载因子(Load factor)：Load factor就是bucket填满程度的最大比例。<br>如果对迭代性能要求很高的话不要把<code>capacity</code>设置过大,也不要吧<code>load factor</code>设置过小，当bucket的entries的数目大于<code>capacity*load factor</code>是就需要调整bucket的大小为当前的2倍。<h4 id=\"put-函数的基本思路\"><a href=\"#put-函数的基本思路\" class=\"headerlink\" title=\"put()函数的基本思路:\"></a><code>put()</code>函数的基本思路:</h4></li>\n</ul>\n<ol>\n<li>对key的<code>hashCode()</code>做hash,然后计算对应的index</li>\n<li>如果没有发生碰撞就直接放到桶里</li>\n<li>如果发生碰撞就采用拉链法,以链表的形式存储在该桶里</li>\n<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD),就把链表转换为红黑树</li>\n<li>如果节点存在,就替换成新的value</li>\n<li>如果桶满了(超过load factor*current capacity),就要resize  </li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> putVal(hash(key),key,value,<span class=\"keyword\">false</span>,<span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash,K key,V value,<span class=\"keyword\">boolean</span> onlyIfAbsent,<span class=\"keyword\">boolean</span> evict)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</div><div class=\"line\">    <span class=\"comment\">// tab为空则创建</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</div><div class=\"line\">        n = (tab = resize()).length;</div><div class=\"line\">    <span class=\"comment\">// 计算index，并对null做处理</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</div><div class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        Node&lt;K,V&gt; e; K k;</div><div class=\"line\">        <span class=\"comment\">// 节点存在</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</div><div class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">            e = p;</div><div class=\"line\">        <span class=\"comment\">// 该链为树</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</div><div class=\"line\">        <span class=\"comment\">// 该链为链表</span></div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></div><div class=\"line\">                        treeifyBin(tab, hash);</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                p = e;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 写入</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></div><div class=\"line\">            V oldValue = e.value;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</div><div class=\"line\">                e.value = value;</div><div class=\"line\">            afterNodeAccess(e);</div><div class=\"line\">            <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ++modCount;</div><div class=\"line\">    <span class=\"comment\">// 超过load factor*current capacity，resize</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</div><div class=\"line\">        resize();</div><div class=\"line\">    afterNodeInsertion(evict);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"get-函数的基本思路\"><a href=\"#get-函数的基本思路\" class=\"headerlink\" title=\"get()函数的基本思路\"></a><code>get()</code>函数的基本思路</h4><ol>\n<li>桶里的第一个节点就直接命中</li>\n<li>如果桶里有冲突，就通过<code>equal()</code>来找查对应的entry，若为树时间复杂度为O(logN)，链表就是O(N)   </li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</div><div class=\"line\">        Node&lt;K,V&gt; e;</div><div class=\"line\">        <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</div><div class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</div><div class=\"line\">            (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 直接命中</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></div><div class=\"line\">                ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                <span class=\"keyword\">return</span> first;</div><div class=\"line\">            <span class=\"comment\">// 未命中</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// 在树中get</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</div><div class=\"line\">                    <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class=\"line\">                <span class=\"comment\">// 在链表中get</span></div><div class=\"line\">                <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</div><div class=\"line\">                        <span class=\"keyword\">return</span> e;</div><div class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意:通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将<code>K/V</code>传给put方法时,它调用hashCode计算hash从而得到bucket位置,进一步存储，<code>HashMap</code>会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时,我们将K传给get,它调用hashCode计算hash从而得到bucket位置,并进一步调用equals()方法确定键值对。如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来,在Java 8中,如果一个bucket中碰撞冲突的元素超过某个限制(默认是8,则使用红黑树来替换链表,从而提高速度 </p>\n<h3 id=\"golang中的map\"><a href=\"#golang中的map\" class=\"headerlink\" title=\"golang中的map\"></a>golang中的map</h3><p>基本认识:在go中一个map就是一个哈希表的引用,map类型可以写为map[K]V,对K的类型要求是必须支持<code>==</code>比较运算符。但是不建议使用浮点型作为Key。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Hmap&#123;<span class=\"comment\">//map的关键数据</span></div><div class=\"line\">    <span class=\"keyword\">uint8</span>   B;    <span class=\"comment\">// 可以容纳2^B个项</span></div><div class=\"line\">    <span class=\"keyword\">uint16</span>  bucketsize;   <span class=\"comment\">// 每个桶的大小</span></div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"keyword\">byte</span>    *buckets;     <span class=\"comment\">// 2^B个Buckets的数组</span></div><div class=\"line\">    <span class=\"keyword\">byte</span>    *oldbuckets;  <span class=\"comment\">// 前一个buckets，只有当正在扩容时才不为空</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//初始化的3种方式</span></div><div class=\"line\">ages:=<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)<span class=\"comment\">// mapping from strings to ints</span></div><div class=\"line\">ages:=<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>&#123;&#125;</div><div class=\"line\">ages:=<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>&#123;</div><div class=\"line\">    <span class=\"string\">\"alice\"</span>:<span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"string\">\"charlie\"</span>:<span class=\"number\">33</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//取值</span></div><div class=\"line\">ages[<span class=\"string\">\"alice\"</span>]=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">//赋值</span></div><div class=\"line\">ages[<span class=\"string\">\"charlie\"</span>]=<span class=\"number\">34</span></div><div class=\"line\"><span class=\"comment\">//删除</span></div><div class=\"line\"><span class=\"built_in\">delete</span>(ages, <span class=\"string\">\"alice\"</span>) <span class=\"comment\">// remove element ages[\"alice\"]</span></div></pre></td></tr></table></figure>\n<p>上面这些都是安全的，及时失败也会返回对应value类型的零值。<br>但是有时候需要想知道对应的元素是否真的在map之中。推荐写法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//map的下标语法将产生两个值；第二个是一个布尔值   </span></div><div class=\"line\"><span class=\"comment\">//用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。</span></div><div class=\"line\"><span class=\"keyword\">if</span> age, ok := ages[<span class=\"string\">\"alice\"</span>]; !ok &#123; <span class=\"comment\">/* ... */</span> &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h4><p>在golang中主要采用增量扩容–扩容因子为<code>6.5</code>。这个主要是为了缩短map容器的响应时间，因为在map桶里面数据很多事,直接复制进行扩容就会很卡，导致较长一段时间无法响应请求。不过具体时间复杂度还是采用的均摊法。具体做法:</p>\n<blockquote>\n<p>扩容会建立一个大小是原来2倍的空表。将旧的bucket搬到新表中(复制),但是并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。</p>\n</blockquote>\n<p>由于整个过程是逐渐完成的,这样就会导致一部分数据还没有完全复制到新表，所以会对insert，remove，get等操作产生影响。并且只有当所有复制操作完成后才会释放oldbucket。  </p>\n<h4 id=\"insert分析基本思路\"><a href=\"#insert分析基本思路\" class=\"headerlink\" title=\"insert分析基本思路\"></a><code>insert</code>分析基本思路</h4><ol>\n<li>根据key算出hash值，进而得出索引的位置</li>\n<li>如果bucket的位置在old table中，就重新hash到新表中</li>\n<li>查找对应的位置，如果在bucket中如果已经存在相应的key，就覆盖原来value，没有就插入</li>\n<li>根据table中元素的个数，判断是否扩容</li>\n<li>如果对应的bucket已经full，重新申请新的bucket作为overbucket(溢出桶链表)。</li>\n<li>将key/value pair插入到bucket中。  </li>\n</ol>\n<h4 id=\"get查找过程\"><a href=\"#get查找过程\" class=\"headerlink\" title=\"get查找过程\"></a><code>get</code>查找过程</h4><ol>\n<li>根据key算出hash值，进而得出索引的位置</li>\n<li>如果存在old table, 首先在old table中查找，如果找到的bucket已经扩容，转到步骤3。 反之，返回其对应的value。</li>\n<li>在new table中查找对应的value。  </li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">do &#123; <span class=\"comment\">//对每个bucket</span></div><div class=\"line\">    <span class=\"comment\">//依次比较桶内的每一项存放的高位hash与所求的hash值高位是否相等</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>, k = b-&gt;data, v = k + h-&gt;keysize * BUCKETSIZE; i &lt; BUCKETSIZE; i++, k += h-&gt;keysize, v += h-&gt;valuesize) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(b-&gt;tophash[i] == top) &#123; </div><div class=\"line\">            k2 = IK(h, k);</div><div class=\"line\">            t-&gt;key-&gt;alg-&gt;equal(&amp;eq, t-&gt;key-&gt;size, key, k2);</div><div class=\"line\">            <span class=\"keyword\">if</span>(eq) &#123; <span class=\"comment\">//相等的情况下再去做key比较...</span></div><div class=\"line\">                *keyp = k2;</div><div class=\"line\">                <span class=\"keyword\">return</span> IV(h, v);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    b = b-&gt;overflow; <span class=\"comment\">//b设置为它的下一下溢出链</span></div><div class=\"line\">&#125; while(b != <span class=\"literal\">nil</span>);</div></pre></td></tr></table></figure>\n<p>这里一个细节需要注意一下。不认真看可能会以为低位用于定位bucket在数组的index，那么高位就是用于key/valule在bucket内部的offset。事实上高8位不是用作offset的，而是用于加快key的比较的。  </p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在扩容过程中，oldbucket是被冻结的，查找时会在oldbucket中查找，但不会在oldbucket中插入数据。如果在oldbucket是找到了相应的key，做法是将它迁移到新bucket后加入扩容标记。<br>然后就是只要在某个bucket中找到第一个空位，就会将key/value插入到这个位置。也就是位置位于bucket前面的会覆盖后面的(类似于存储系统设计中做删除时的常用的技巧之一，直接用新数据追加方式写，新版本数据覆盖老版本数据)。找到了相同的key或者找到第一个空位就可以结束遍历了。不过这也意味着做删除时必须完全的遍历bucket所有溢出链，将所有的相同key数据都删除。所以目前map的设计是为插入而优化的，删除效率会比插入低一些。  </p>\n<hr>\n<p>参考:<br><a href=\"http://tech.meituan.com/java-hashmap.html\">Java 8系列之重新认识HashMap</a><br><a href=\"http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/\">Java HashMap工作原理及实现</a></p>"},{"title":"session和cookie","date":"2016-12-22T10:35:35.000Z","_content":"### 基本认识  \n首先有一点必须特别的清楚： 因为HTTP协议是无状态的，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，对于一个浏览器发出的多次请求，WEB服务器无法区分 是不是来源于同一个浏览器，更别说是否是来自同一用户。为了保持用户的状态，有了两种机制，一般用户客户端的cookie机制，和用于服务器端的session机制，这两种机制都是为了保持状态，既有联系又有区别。\n### cookie基本实现机制  \n现在的cookie是HTTP协议的一部分，一般存在HTTP的响应头，内容是一系列的键值对的形式，简单说：cookie就是服务器在用户的浏览器中存储的一小段文本文件（大小不能超过3K）不包含任何可执行代码，里面一般包含的是用户的登录信息之类的比较少的，用来验证用户是否合法（不止局限与此，cookie是用来记录状态的，也可以是购物的等一系列状态，让服务器知道我们浏览了那些地方，购物对那些感兴趣，一般很多广告都是根据这个东西来推送的，你在某购物网站买了一个东西，然后浏览别的网站，发现广告都是和你浏览的相关）。  cookie的内容主要包括：key-value,Expires（过期时间），path和domain。path和domain一起构成cookie的作用范围。  \n![](http://ofa8x9gy9.bkt.clouddn.com/cookie.png)  \n&emsp;&emsp;&emsp;&emsp;现在的cookie，内容经过加密了\ncookie的实现流程：  \n1. 浏览器向某个URL发起HTTP请求 （可以是任何请求，比如GET，POST等）\n2. 对应的服务器收到该HTTP请求，并做相应的响应（响应头和请求体两部分），在响应的头中加入`Set-Cookie`字段（设置相应的cookie，cookie是多个`key-value`组成的）\n<!--more-->\n3. 浏览器收到来自服务器的HTTP响应\n4. 浏览器在响应头中发现存在`Set-Cookie`字段，就会将相应的cookie(key-value)保存在内存或者硬盘中。需要注意的是`Set-Value`字段可以包含多个cookie,每一项都可以指定过期时间，默认的过期的时间是用户浏览器关闭的时候\n5. 浏览器下次给该服务器发送HTTP请求时，会将服务器设置的cookie附加在HTTP请求头`Cookie`中浏览器可以存储多个不同域名下的Cookie，但只发送当前请求的域名曾经指定的域名，这个可以在`Set-Cookie`中指定\n6. 服务器收到这个HTTP请求，发现请求头中有`Cookie`字段，就知道这个用户的状态。获取相应的信息进行响应。  \n这就是整个基本的cookie机制。保存了用户的操作状态，但是还需要注意的是,cookies是通过明文传递。在HTTP包中容易被劫持和伪造，是不安全的，不应该存一些比较重要的东西。还有就是cookie在整个会话都会在HTTP的请求中，增加了流量。     \n\n### session的基本实现机制  \n有一个session是不能改变的，是为了维持住HTTP的状态，所以在用户每次发起HTTP请求的时候，都需要让服务器知道是那个用户发起的这个请求，然后查找这个用户的状态，在进行相应的处理。session的实现基于这点，就需要一个唯一的ID标志某个用户（session）然后在这个ID中对应多个键值对来保证用户的状态，所以前后端只需要传递一个sessionId，服务器就可找到对应的状态（这个对应的键值对可以存在redies或者数据库中）。前后端传递值基本有三种：一种是直接写在URL中，一种通过表单中的隐藏域来提交，还有一种是现在流行的做法，通过在cookie中设置一个键值对`jsessionId=${sessionId}`在传递。现在第一二种都不是很建议这么做，当然在浏览器禁用的情况下也可以通过前面两种来传递，不过一般浏览器都支持使用cookie的方式。 \n\n### 两种方式的区别和联系  \n\n1. cookie数据存放在客户的浏览器上，session数据放在服务器上。\n2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。\n3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n   考虑到减轻服务器性能方面，应当使用cookie。\n4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n联系是：两个都是用来保持HTTP协议状态的方式，一种是客户端的实现，一种是服务器端的实现。但是session可以依赖于cookie来传递sessionId\n\n### 一个小项目例子--在微信中开发的小程序（公众号自动回复）里面的session问题  \n首先简单描述下小项目:用户在公众号中输入某一个触发关键词（项目里面的例子是：绑定），然后就进入绑定所涉及的流程。用户在公众中输入触发词，是由微信的服务器进行响应，然后转发到程序的服务器。程序的服务器在把处理的结果（用规定的格式）传递给微信的服务器，由微信的服务器进行响应给用户。整个项目用golang开发，简单的使用了beego框架。\n#### 基于session来实现（初始版）\n```go \nfunc (c *MainController) Dispatch() {\n\t//进行请求的分发，和request数据的解析,POST\n\tw := new(models.WeixinUser)\n\txml.Unmarshal(c.Ctx.Input.RequestBody,&w)\n\t//第一步是判断是否为开启逻辑的语句，同一个逻辑只能同时开启一次\n\tstr:=w.Content\n\tsc:=c.GetSession(\"status-count\").(int)\n\tswitch str {\n\tcase \"绑定\": //如果匹配进入绑定，判断是否同时开启两次\n\t\tstr0:=\"\"\n\t\tbinds:=assertionInt(c.GetSession(\"bindstep\"))\n\t\tif binds==-1{\n\t\t\tc.SetSession(\"bindstep\",int(1))\n\t\t\tsc++;\n\t\t\tc.SetSession(\"status-count\",int(sc))\n\t\t\tc.SetSession(\"status-\"+strconv.Itoa(sc),string(\"bind\"))\n\t\t\t_,str0=bind(c,w)\n\t\t}\n\t\tif str0==\"\"{\n\t\t\tstr0=\"已经进入绑定流程\"\n\t\t}\n\t\tprints(c,w,str0)\n\t\treturn\n\t}\n\t//第二步判断有多少个session保持者状态，从0开始计数,输入的数据从最上面的应用进行匹配处理\n\tif sc >=0 {//判断是否有触发的逻辑\n\t\tfor i:=sc;i>=0;i--{//进行逻辑匹配\n\t\t\tstr2:=c.GetSession(\"status-\"+strconv.Itoa(i)).(string)\n\t\t\tif str2!=\"\"{\n\t\t\t\tstr1:=\" \"//进行默认的逻辑处理，不做回应\n\t\t\t\tswitch str2 {\n\t\t\t\tcase \"bind\":\n\t\t\t\t\tcode,src:=bind(c,w)//code用来处理完成逻辑后的删除session的作用\n\t\t\t\t\tif code==1{\n\t\t\t\t\t\tc.DelSession(\"status-\"+strconv.Itoa(i))\n\t\t\t\t\t\tc.SetSession(\"status-count\",int(sc-1))\n\t\t\t\t\t\tsc--;\n\t\t\t\t\t}\n\t\t\t\t\tstr1=src\n\t\t\t\t}\n\t\t\t\tif str1 != \" \"{//如果进行处理就退出逻辑\n\t\t\t\t\tprints(c,w,str1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif str1 ==\" \"&&i==0{\n\t\t\t\t\tstr1=\"输入格式错误\"\n\t\t\t\t\tprints(c,w,str1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstr=\"输入：绑定，可以进入绑定流程\"\n\tprints(c,w,str)\n}\nfunc bind(c *MainController,w *models.WeixinUser) (int,string) {\n//进行绑定请求的处理，如果匹配不上，退出同时开始另一个逻辑的匹配\n\tstep:=c.GetSession(\"bindstep\").(string)//内部逻辑计数器，记住用户的处理的位置，从1开始计数\n\tif step==1||step==2||step==3||step==4{\n\t\tswitch step {\n\t\tcase 1://用户输入进入词，进入逻辑\n\t\t\tc.SetSession(\"bindstep\",int(2))\n\t\t\treturn 0,\"请输入手机号，进行绑定\"\n\t\tcase 2://用户输入了手机号，发送短信，获取验证码\n\t\t\t//todo 验证手机号格式并且发短信验证验证码\n\t\t\tok:=validatePhone(w.Content)\n\t\t\tif !ok{\n\t\t\t\treturn 0,\"手机号格式不正确，请重新输入\"\n\t\t\t}\n\t\t\talidayu.AppKey=\"*******\"\n\t\t\talidayu.AppSecret=\"**************\"\n\t\t\talidayu.UseHTTP=true\n\t\t\tstr:=randNum()//生成随机4位数字\n\t\t\tsuccess,_:=alidayu.SendSMS(w.Content,\"德玛西亚\",\"********\", `{ \"code\":\"`+str+`\"}`)\n\t\t\tif !success{\n\t\t\t\treturn 0,\"验证码发送失败，请重新输入手机号\"\n\t\t\t}\n\t\t\tc.SetSession(\"rand\",str)\n\t\t\tf:=models.Fluge{}\n\t\t\tf.Openid=w.FromUserName\n\t\t\tf.Phone=w.Content\n\t\t\tc.SetSession(\"fluge\",f)\n\t\t\tc.SetSession(\"bindstep\",int(3))\n\t\t\treturn 0,\"验证码已发送，请输入验证码完成绑定\"\n\t\tcase 3://进行验证码的验证，成功就开始绑定\n\t\t\tif w.Content==c.GetSession(\"rand\").(string) {\n\t\t\t\tf:=c.GetSession(\"fluge\").(*models.Fluge)\n\t\t\t\tc.DelSession(\"fluge\")\n\t\t\t\tc.DelSession(\"rand\")\n\t\t\t\tflag,_:=models.CheckUser(f)\n\t\t\t\tif flag {\n\t\t\t\t\tstr3, err := models.AddUser(f)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, str3\n\t\t\t\t\t}\n\t\t\t\t\tc.SetSession(\"bindstep\", int(4))\n\t\t\t\t\treturn 0, str3\n\t\t\t\t}\n\t\t\t\tc.SetSession(\"bindstep\",int(2))\n\t\t\t\treturn 0,\"手机号无法重复绑定，请重新输入手机号\"\n\t\t\t}\n\t\t\treturn 0,\"验证码错误，请重新输入\"\n\t\tcase 4://用户已经完成绑定，等待退出\n\t\t\tif w.Content==\"8\" {\n\t\t\t\tc.DelSession(\"bindstep\")\n\t\t\t\treturn 1,\"谢谢使用\"\n\t\t\t}\n\t\t\treturn 0,\"绑定完成，请输入8退出\"\n\t\t}\n\t}\n\treturn 0,\" \"\n}\n```\n  \n现在这个程序是执行不了的。在beego中默认传递sessionId是cookie。但如果我在程序中必须使用session保持用户的状态（不然流程没办法继续下去）。两个服务器之间的交互式没有办法传递cookie。所以就会出现在一直在第一个流程，无法进入第二个流程。  \n#### 解决\n首先明白一点，sessionId的作用是一个唯一标识符，用来标记同一个用户。但是在微信的整个架构中有一个跟sessionId很类似的东西:openid:用户对于某个公众号唯一的标识。所以在微信服务器向程序的服务器提交POST消息市本身也会自带这个openid。这样就为解决session提供了遍历。  \n不需要额外去产生和传递sessionId。直接使用openid来作为用户的唯一标识符。  \n![](http://ofa8x9gy9.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%97%E6%B6%88%E6%81%AF.png)  \n然后对于sessionId对应的具体内容我选择了方便的redis来存储  \n实现代码--直接复写了beego的Getseeion和SetSession方法    \n\n```golang\nfunc (c *MainController)initSession(sid string) {\n\tconfig := &redissession.SessionConfig{\n\t\tPrefix:\"lyfluge-\",\n\t\tRedisHost:\"**********\",\n\t\tRedisPassword:\"f***********\",\n\t\tLifeTime: 60 * time.Second,\n\t}\n\tc.sesion = redissession.NewSession(\"redis\",config)\n\tc.sesion.SetSessionID(sid)\n\tc.sesion.Start()\n}\nfunc (c *MainController)storeSession() {\n\tc.sesion.Store()\n}\nfunc (c *MainController) SetSession(str string,value interface{})interface{}{\n\treturn c.sesion.Set(str,value)\n}\nfunc (c *MainController) GetSession(str string) interface{}{\n\treturn c.sesion.Get(str)\n}\nfunc (c *MainController) DelSession(str string) interface{}{\n\treturn c.sesion.Delete(str)\n}\n//在Dispatch函数中取到对应的sessionId，然后进行状态判断\nfunc (c *MainController) Dispatch() {\n\t//进行请求的分发，和request数据的解析.POST\n\tw := new(models.WeixinUser)\n\txml.Unmarshal(c.Ctx.Input.RequestBody,&w)\n\tc.initSession(w.FromUserName)\n   /..../\n}\n```\n完整代码(包括微信golang的接入,大鱼短信,beego,session-redis的具体实现):\n#### 总结  \nsession中的sessionId是用来标志唯一用户的。通过找到这个用户来判断用户的状态  \n\n----  \n参考:[Cookie/Session的机制与安全](http://harttle.com/2015/08/10/cookie-session.html)","source":"_posts/session和cookie.md","raw":"---\ntitle: session和cookie\ndate: 2016-12-22 18:35:35\ncategories: \n- web\ntags:\n- session\n- cookie\n---\n### 基本认识  \n首先有一点必须特别的清楚： 因为HTTP协议是无状态的，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，对于一个浏览器发出的多次请求，WEB服务器无法区分 是不是来源于同一个浏览器，更别说是否是来自同一用户。为了保持用户的状态，有了两种机制，一般用户客户端的cookie机制，和用于服务器端的session机制，这两种机制都是为了保持状态，既有联系又有区别。\n### cookie基本实现机制  \n现在的cookie是HTTP协议的一部分，一般存在HTTP的响应头，内容是一系列的键值对的形式，简单说：cookie就是服务器在用户的浏览器中存储的一小段文本文件（大小不能超过3K）不包含任何可执行代码，里面一般包含的是用户的登录信息之类的比较少的，用来验证用户是否合法（不止局限与此，cookie是用来记录状态的，也可以是购物的等一系列状态，让服务器知道我们浏览了那些地方，购物对那些感兴趣，一般很多广告都是根据这个东西来推送的，你在某购物网站买了一个东西，然后浏览别的网站，发现广告都是和你浏览的相关）。  cookie的内容主要包括：key-value,Expires（过期时间），path和domain。path和domain一起构成cookie的作用范围。  \n![](http://ofa8x9gy9.bkt.clouddn.com/cookie.png)  \n&emsp;&emsp;&emsp;&emsp;现在的cookie，内容经过加密了\ncookie的实现流程：  \n1. 浏览器向某个URL发起HTTP请求 （可以是任何请求，比如GET，POST等）\n2. 对应的服务器收到该HTTP请求，并做相应的响应（响应头和请求体两部分），在响应的头中加入`Set-Cookie`字段（设置相应的cookie，cookie是多个`key-value`组成的）\n<!--more-->\n3. 浏览器收到来自服务器的HTTP响应\n4. 浏览器在响应头中发现存在`Set-Cookie`字段，就会将相应的cookie(key-value)保存在内存或者硬盘中。需要注意的是`Set-Value`字段可以包含多个cookie,每一项都可以指定过期时间，默认的过期的时间是用户浏览器关闭的时候\n5. 浏览器下次给该服务器发送HTTP请求时，会将服务器设置的cookie附加在HTTP请求头`Cookie`中浏览器可以存储多个不同域名下的Cookie，但只发送当前请求的域名曾经指定的域名，这个可以在`Set-Cookie`中指定\n6. 服务器收到这个HTTP请求，发现请求头中有`Cookie`字段，就知道这个用户的状态。获取相应的信息进行响应。  \n这就是整个基本的cookie机制。保存了用户的操作状态，但是还需要注意的是,cookies是通过明文传递。在HTTP包中容易被劫持和伪造，是不安全的，不应该存一些比较重要的东西。还有就是cookie在整个会话都会在HTTP的请求中，增加了流量。     \n\n### session的基本实现机制  \n有一个session是不能改变的，是为了维持住HTTP的状态，所以在用户每次发起HTTP请求的时候，都需要让服务器知道是那个用户发起的这个请求，然后查找这个用户的状态，在进行相应的处理。session的实现基于这点，就需要一个唯一的ID标志某个用户（session）然后在这个ID中对应多个键值对来保证用户的状态，所以前后端只需要传递一个sessionId，服务器就可找到对应的状态（这个对应的键值对可以存在redies或者数据库中）。前后端传递值基本有三种：一种是直接写在URL中，一种通过表单中的隐藏域来提交，还有一种是现在流行的做法，通过在cookie中设置一个键值对`jsessionId=${sessionId}`在传递。现在第一二种都不是很建议这么做，当然在浏览器禁用的情况下也可以通过前面两种来传递，不过一般浏览器都支持使用cookie的方式。 \n\n### 两种方式的区别和联系  \n\n1. cookie数据存放在客户的浏览器上，session数据放在服务器上。\n2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。\n3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n   考虑到减轻服务器性能方面，应当使用cookie。\n4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n联系是：两个都是用来保持HTTP协议状态的方式，一种是客户端的实现，一种是服务器端的实现。但是session可以依赖于cookie来传递sessionId\n\n### 一个小项目例子--在微信中开发的小程序（公众号自动回复）里面的session问题  \n首先简单描述下小项目:用户在公众号中输入某一个触发关键词（项目里面的例子是：绑定），然后就进入绑定所涉及的流程。用户在公众中输入触发词，是由微信的服务器进行响应，然后转发到程序的服务器。程序的服务器在把处理的结果（用规定的格式）传递给微信的服务器，由微信的服务器进行响应给用户。整个项目用golang开发，简单的使用了beego框架。\n#### 基于session来实现（初始版）\n```go \nfunc (c *MainController) Dispatch() {\n\t//进行请求的分发，和request数据的解析,POST\n\tw := new(models.WeixinUser)\n\txml.Unmarshal(c.Ctx.Input.RequestBody,&w)\n\t//第一步是判断是否为开启逻辑的语句，同一个逻辑只能同时开启一次\n\tstr:=w.Content\n\tsc:=c.GetSession(\"status-count\").(int)\n\tswitch str {\n\tcase \"绑定\": //如果匹配进入绑定，判断是否同时开启两次\n\t\tstr0:=\"\"\n\t\tbinds:=assertionInt(c.GetSession(\"bindstep\"))\n\t\tif binds==-1{\n\t\t\tc.SetSession(\"bindstep\",int(1))\n\t\t\tsc++;\n\t\t\tc.SetSession(\"status-count\",int(sc))\n\t\t\tc.SetSession(\"status-\"+strconv.Itoa(sc),string(\"bind\"))\n\t\t\t_,str0=bind(c,w)\n\t\t}\n\t\tif str0==\"\"{\n\t\t\tstr0=\"已经进入绑定流程\"\n\t\t}\n\t\tprints(c,w,str0)\n\t\treturn\n\t}\n\t//第二步判断有多少个session保持者状态，从0开始计数,输入的数据从最上面的应用进行匹配处理\n\tif sc >=0 {//判断是否有触发的逻辑\n\t\tfor i:=sc;i>=0;i--{//进行逻辑匹配\n\t\t\tstr2:=c.GetSession(\"status-\"+strconv.Itoa(i)).(string)\n\t\t\tif str2!=\"\"{\n\t\t\t\tstr1:=\" \"//进行默认的逻辑处理，不做回应\n\t\t\t\tswitch str2 {\n\t\t\t\tcase \"bind\":\n\t\t\t\t\tcode,src:=bind(c,w)//code用来处理完成逻辑后的删除session的作用\n\t\t\t\t\tif code==1{\n\t\t\t\t\t\tc.DelSession(\"status-\"+strconv.Itoa(i))\n\t\t\t\t\t\tc.SetSession(\"status-count\",int(sc-1))\n\t\t\t\t\t\tsc--;\n\t\t\t\t\t}\n\t\t\t\t\tstr1=src\n\t\t\t\t}\n\t\t\t\tif str1 != \" \"{//如果进行处理就退出逻辑\n\t\t\t\t\tprints(c,w,str1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif str1 ==\" \"&&i==0{\n\t\t\t\t\tstr1=\"输入格式错误\"\n\t\t\t\t\tprints(c,w,str1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstr=\"输入：绑定，可以进入绑定流程\"\n\tprints(c,w,str)\n}\nfunc bind(c *MainController,w *models.WeixinUser) (int,string) {\n//进行绑定请求的处理，如果匹配不上，退出同时开始另一个逻辑的匹配\n\tstep:=c.GetSession(\"bindstep\").(string)//内部逻辑计数器，记住用户的处理的位置，从1开始计数\n\tif step==1||step==2||step==3||step==4{\n\t\tswitch step {\n\t\tcase 1://用户输入进入词，进入逻辑\n\t\t\tc.SetSession(\"bindstep\",int(2))\n\t\t\treturn 0,\"请输入手机号，进行绑定\"\n\t\tcase 2://用户输入了手机号，发送短信，获取验证码\n\t\t\t//todo 验证手机号格式并且发短信验证验证码\n\t\t\tok:=validatePhone(w.Content)\n\t\t\tif !ok{\n\t\t\t\treturn 0,\"手机号格式不正确，请重新输入\"\n\t\t\t}\n\t\t\talidayu.AppKey=\"*******\"\n\t\t\talidayu.AppSecret=\"**************\"\n\t\t\talidayu.UseHTTP=true\n\t\t\tstr:=randNum()//生成随机4位数字\n\t\t\tsuccess,_:=alidayu.SendSMS(w.Content,\"德玛西亚\",\"********\", `{ \"code\":\"`+str+`\"}`)\n\t\t\tif !success{\n\t\t\t\treturn 0,\"验证码发送失败，请重新输入手机号\"\n\t\t\t}\n\t\t\tc.SetSession(\"rand\",str)\n\t\t\tf:=models.Fluge{}\n\t\t\tf.Openid=w.FromUserName\n\t\t\tf.Phone=w.Content\n\t\t\tc.SetSession(\"fluge\",f)\n\t\t\tc.SetSession(\"bindstep\",int(3))\n\t\t\treturn 0,\"验证码已发送，请输入验证码完成绑定\"\n\t\tcase 3://进行验证码的验证，成功就开始绑定\n\t\t\tif w.Content==c.GetSession(\"rand\").(string) {\n\t\t\t\tf:=c.GetSession(\"fluge\").(*models.Fluge)\n\t\t\t\tc.DelSession(\"fluge\")\n\t\t\t\tc.DelSession(\"rand\")\n\t\t\t\tflag,_:=models.CheckUser(f)\n\t\t\t\tif flag {\n\t\t\t\t\tstr3, err := models.AddUser(f)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, str3\n\t\t\t\t\t}\n\t\t\t\t\tc.SetSession(\"bindstep\", int(4))\n\t\t\t\t\treturn 0, str3\n\t\t\t\t}\n\t\t\t\tc.SetSession(\"bindstep\",int(2))\n\t\t\t\treturn 0,\"手机号无法重复绑定，请重新输入手机号\"\n\t\t\t}\n\t\t\treturn 0,\"验证码错误，请重新输入\"\n\t\tcase 4://用户已经完成绑定，等待退出\n\t\t\tif w.Content==\"8\" {\n\t\t\t\tc.DelSession(\"bindstep\")\n\t\t\t\treturn 1,\"谢谢使用\"\n\t\t\t}\n\t\t\treturn 0,\"绑定完成，请输入8退出\"\n\t\t}\n\t}\n\treturn 0,\" \"\n}\n```\n  \n现在这个程序是执行不了的。在beego中默认传递sessionId是cookie。但如果我在程序中必须使用session保持用户的状态（不然流程没办法继续下去）。两个服务器之间的交互式没有办法传递cookie。所以就会出现在一直在第一个流程，无法进入第二个流程。  \n#### 解决\n首先明白一点，sessionId的作用是一个唯一标识符，用来标记同一个用户。但是在微信的整个架构中有一个跟sessionId很类似的东西:openid:用户对于某个公众号唯一的标识。所以在微信服务器向程序的服务器提交POST消息市本身也会自带这个openid。这样就为解决session提供了遍历。  \n不需要额外去产生和传递sessionId。直接使用openid来作为用户的唯一标识符。  \n![](http://ofa8x9gy9.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%97%E6%B6%88%E6%81%AF.png)  \n然后对于sessionId对应的具体内容我选择了方便的redis来存储  \n实现代码--直接复写了beego的Getseeion和SetSession方法    \n\n```golang\nfunc (c *MainController)initSession(sid string) {\n\tconfig := &redissession.SessionConfig{\n\t\tPrefix:\"lyfluge-\",\n\t\tRedisHost:\"**********\",\n\t\tRedisPassword:\"f***********\",\n\t\tLifeTime: 60 * time.Second,\n\t}\n\tc.sesion = redissession.NewSession(\"redis\",config)\n\tc.sesion.SetSessionID(sid)\n\tc.sesion.Start()\n}\nfunc (c *MainController)storeSession() {\n\tc.sesion.Store()\n}\nfunc (c *MainController) SetSession(str string,value interface{})interface{}{\n\treturn c.sesion.Set(str,value)\n}\nfunc (c *MainController) GetSession(str string) interface{}{\n\treturn c.sesion.Get(str)\n}\nfunc (c *MainController) DelSession(str string) interface{}{\n\treturn c.sesion.Delete(str)\n}\n//在Dispatch函数中取到对应的sessionId，然后进行状态判断\nfunc (c *MainController) Dispatch() {\n\t//进行请求的分发，和request数据的解析.POST\n\tw := new(models.WeixinUser)\n\txml.Unmarshal(c.Ctx.Input.RequestBody,&w)\n\tc.initSession(w.FromUserName)\n   /..../\n}\n```\n完整代码(包括微信golang的接入,大鱼短信,beego,session-redis的具体实现):\n#### 总结  \nsession中的sessionId是用来标志唯一用户的。通过找到这个用户来判断用户的状态  \n\n----  \n参考:[Cookie/Session的机制与安全](http://harttle.com/2015/08/10/cookie-session.html)","slug":"session和cookie","published":1,"updated":"2016-12-22T06:04:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2btq000dkhikzks2h403","content":"<h3 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h3><p>首先有一点必须特别的清楚： 因为HTTP协议是无状态的，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，对于一个浏览器发出的多次请求，WEB服务器无法区分 是不是来源于同一个浏览器，更别说是否是来自同一用户。为了保持用户的状态，有了两种机制，一般用户客户端的cookie机制，和用于服务器端的session机制，这两种机制都是为了保持状态，既有联系又有区别。</p>\n<h3 id=\"cookie基本实现机制\"><a href=\"#cookie基本实现机制\" class=\"headerlink\" title=\"cookie基本实现机制\"></a>cookie基本实现机制</h3><p>现在的cookie是HTTP协议的一部分，一般存在HTTP的响应头，内容是一系列的键值对的形式，简单说：cookie就是服务器在用户的浏览器中存储的一小段文本文件（大小不能超过3K）不包含任何可执行代码，里面一般包含的是用户的登录信息之类的比较少的，用来验证用户是否合法（不止局限与此，cookie是用来记录状态的，也可以是购物的等一系列状态，让服务器知道我们浏览了那些地方，购物对那些感兴趣，一般很多广告都是根据这个东西来推送的，你在某购物网站买了一个东西，然后浏览别的网站，发现广告都是和你浏览的相关）。  cookie的内容主要包括：key-value,Expires（过期时间），path和domain。path和domain一起构成cookie的作用范围。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/cookie.png\" alt=\"\"><br>&emsp;&emsp;&emsp;&emsp;现在的cookie，内容经过加密了<br>cookie的实现流程：  </p>\n<ol>\n<li>浏览器向某个URL发起HTTP请求 （可以是任何请求，比如GET，POST等）</li>\n<li>对应的服务器收到该HTTP请求，并做相应的响应（响应头和请求体两部分），在响应的头中加入<code>Set-Cookie</code>字段（设置相应的cookie，cookie是多个<code>key-value</code>组成的）<a id=\"more\"></a></li>\n<li>浏览器收到来自服务器的HTTP响应</li>\n<li>浏览器在响应头中发现存在<code>Set-Cookie</code>字段，就会将相应的cookie(key-value)保存在内存或者硬盘中。需要注意的是<code>Set-Value</code>字段可以包含多个cookie,每一项都可以指定过期时间，默认的过期的时间是用户浏览器关闭的时候</li>\n<li>浏览器下次给该服务器发送HTTP请求时，会将服务器设置的cookie附加在HTTP请求头<code>Cookie</code>中浏览器可以存储多个不同域名下的Cookie，但只发送当前请求的域名曾经指定的域名，这个可以在<code>Set-Cookie</code>中指定</li>\n<li>服务器收到这个HTTP请求，发现请求头中有<code>Cookie</code>字段，就知道这个用户的状态。获取相应的信息进行响应。<br>这就是整个基本的cookie机制。保存了用户的操作状态，但是还需要注意的是,cookies是通过明文传递。在HTTP包中容易被劫持和伪造，是不安全的，不应该存一些比较重要的东西。还有就是cookie在整个会话都会在HTTP的请求中，增加了流量。     </li>\n</ol>\n<h3 id=\"session的基本实现机制\"><a href=\"#session的基本实现机制\" class=\"headerlink\" title=\"session的基本实现机制\"></a>session的基本实现机制</h3><p>有一个session是不能改变的，是为了维持住HTTP的状态，所以在用户每次发起HTTP请求的时候，都需要让服务器知道是那个用户发起的这个请求，然后查找这个用户的状态，在进行相应的处理。session的实现基于这点，就需要一个唯一的ID标志某个用户（session）然后在这个ID中对应多个键值对来保证用户的状态，所以前后端只需要传递一个sessionId，服务器就可找到对应的状态（这个对应的键值对可以存在redies或者数据库中）。前后端传递值基本有三种：一种是直接写在URL中，一种通过表单中的隐藏域来提交，还有一种是现在流行的做法，通过在cookie中设置一个键值对<code>jsessionId=${sessionId}</code>在传递。现在第一二种都不是很建议这么做，当然在浏览器禁用的情况下也可以通过前面两种来传递，不过一般浏览器都支持使用cookie的方式。 </p>\n<h3 id=\"两种方式的区别和联系\"><a href=\"#两种方式的区别和联系\" class=\"headerlink\" title=\"两种方式的区别和联系\"></a>两种方式的区别和联系</h3><ol>\n<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>\n<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li>\n<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>考虑到减轻服务器性能方面，应当使用cookie。</li>\n<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>联系是：两个都是用来保持HTTP协议状态的方式，一种是客户端的实现，一种是服务器端的实现。但是session可以依赖于cookie来传递sessionId</li>\n</ol>\n<h3 id=\"一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题\"><a href=\"#一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题\" class=\"headerlink\" title=\"一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题\"></a>一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题</h3><p>首先简单描述下小项目:用户在公众号中输入某一个触发关键词（项目里面的例子是：绑定），然后就进入绑定所涉及的流程。用户在公众中输入触发词，是由微信的服务器进行响应，然后转发到程序的服务器。程序的服务器在把处理的结果（用规定的格式）传递给微信的服务器，由微信的服务器进行响应给用户。整个项目用golang开发，简单的使用了beego框架。</p>\n<h4 id=\"基于session来实现（初始版）\"><a href=\"#基于session来实现（初始版）\" class=\"headerlink\" title=\"基于session来实现（初始版）\"></a>基于session来实现（初始版）</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">Dispatch</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"comment\">//进行请求的分发，和request数据的解析,POST</span></div><div class=\"line\">\tw := <span class=\"built_in\">new</span>(models.WeixinUser)</div><div class=\"line\">\txml.Unmarshal(c.Ctx.Input.RequestBody,&amp;w)</div><div class=\"line\">\t<span class=\"comment\">//第一步是判断是否为开启逻辑的语句，同一个逻辑只能同时开启一次</span></div><div class=\"line\">\tstr:=w.Content</div><div class=\"line\">\tsc:=c.GetSession(<span class=\"string\">\"status-count\"</span>).(<span class=\"keyword\">int</span>)</div><div class=\"line\">\t<span class=\"keyword\">switch</span> str &#123;</div><div class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">\"绑定\"</span>: <span class=\"comment\">//如果匹配进入绑定，判断是否同时开启两次</span></div><div class=\"line\">\t\tstr0:=<span class=\"string\">\"\"</span></div><div class=\"line\">\t\tbinds:=assertionInt(c.GetSession(<span class=\"string\">\"bindstep\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> binds==<span class=\"number\">-1</span>&#123;</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>,<span class=\"keyword\">int</span>(<span class=\"number\">1</span>))</div><div class=\"line\">\t\t\tsc++;</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"status-count\"</span>,<span class=\"keyword\">int</span>(sc))</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"status-\"</span>+strconv.Itoa(sc),<span class=\"keyword\">string</span>(<span class=\"string\">\"bind\"</span>))</div><div class=\"line\">\t\t\t_,str0=bind(c,w)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> str0==<span class=\"string\">\"\"</span>&#123;</div><div class=\"line\">\t\t\tstr0=<span class=\"string\">\"已经进入绑定流程\"</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tprints(c,w,str0)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//第二步判断有多少个session保持者状态，从0开始计数,输入的数据从最上面的应用进行匹配处理</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> sc &gt;=<span class=\"number\">0</span> &#123;<span class=\"comment\">//判断是否有触发的逻辑</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span> i:=sc;i&gt;=<span class=\"number\">0</span>;i--&#123;<span class=\"comment\">//进行逻辑匹配</span></div><div class=\"line\">\t\t\tstr2:=c.GetSession(<span class=\"string\">\"status-\"</span>+strconv.Itoa(i)).(<span class=\"keyword\">string</span>)</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> str2!=<span class=\"string\">\"\"</span>&#123;</div><div class=\"line\">\t\t\t\tstr1:=<span class=\"string\">\" \"</span><span class=\"comment\">//进行默认的逻辑处理，不做回应</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> str2 &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"bind\"</span>:</div><div class=\"line\">\t\t\t\t\tcode,src:=bind(c,w)<span class=\"comment\">//code用来处理完成逻辑后的删除session的作用</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> code==<span class=\"number\">1</span>&#123;</div><div class=\"line\">\t\t\t\t\t\tc.DelSession(<span class=\"string\">\"status-\"</span>+strconv.Itoa(i))</div><div class=\"line\">\t\t\t\t\t\tc.SetSession(<span class=\"string\">\"status-count\"</span>,<span class=\"keyword\">int</span>(sc<span class=\"number\">-1</span>))</div><div class=\"line\">\t\t\t\t\t\tsc--;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\tstr1=src</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> str1 != <span class=\"string\">\" \"</span>&#123;<span class=\"comment\">//如果进行处理就退出逻辑</span></div><div class=\"line\">\t\t\t\t\tprints(c,w,str1)</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> str1 ==<span class=\"string\">\" \"</span>&amp;&amp;i==<span class=\"number\">0</span>&#123;</div><div class=\"line\">\t\t\t\t\tstr1=<span class=\"string\">\"输入格式错误\"</span></div><div class=\"line\">\t\t\t\t\tprints(c,w,str1)</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tstr=<span class=\"string\">\"输入：绑定，可以进入绑定流程\"</span></div><div class=\"line\">\tprints(c,w,str)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bind</span><span class=\"params\">(c *MainController,w *models.WeixinUser)</span> <span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\"><span class=\"comment\">//进行绑定请求的处理，如果匹配不上，退出同时开始另一个逻辑的匹配</span></div><div class=\"line\">\tstep:=c.GetSession(<span class=\"string\">\"bindstep\"</span>).(<span class=\"keyword\">string</span>)<span class=\"comment\">//内部逻辑计数器，记住用户的处理的位置，从1开始计数</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> step==<span class=\"number\">1</span>||step==<span class=\"number\">2</span>||step==<span class=\"number\">3</span>||step==<span class=\"number\">4</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">switch</span> step &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:<span class=\"comment\">//用户输入进入词，进入逻辑</span></div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>,<span class=\"keyword\">int</span>(<span class=\"number\">2</span>))</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"请输入手机号，进行绑定\"</span></div><div class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:<span class=\"comment\">//用户输入了手机号，发送短信，获取验证码</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//todo 验证手机号格式并且发短信验证验证码</span></div><div class=\"line\">\t\t\tok:=validatePhone(w.Content)</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"手机号格式不正确，请重新输入\"</span></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\talidayu.AppKey=<span class=\"string\">\"*******\"</span></div><div class=\"line\">\t\t\talidayu.AppSecret=<span class=\"string\">\"**************\"</span></div><div class=\"line\">\t\t\talidayu.UseHTTP=<span class=\"literal\">true</span></div><div class=\"line\">\t\t\tstr:=randNum()<span class=\"comment\">//生成随机4位数字</span></div><div class=\"line\">\t\t\tsuccess,_:=alidayu.SendSMS(w.Content,<span class=\"string\">\"德玛西亚\"</span>,<span class=\"string\">\"********\"</span>, <span class=\"string\">`&#123; \"code\":\"`</span>+str+<span class=\"string\">`\"&#125;`</span>)</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> !success&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"验证码发送失败，请重新输入手机号\"</span></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"rand\"</span>,str)</div><div class=\"line\">\t\t\tf:=models.Fluge&#123;&#125;</div><div class=\"line\">\t\t\tf.Openid=w.FromUserName</div><div class=\"line\">\t\t\tf.Phone=w.Content</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"fluge\"</span>,f)</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>,<span class=\"keyword\">int</span>(<span class=\"number\">3</span>))</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"验证码已发送，请输入验证码完成绑定\"</span></div><div class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:<span class=\"comment\">//进行验证码的验证，成功就开始绑定</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> w.Content==c.GetSession(<span class=\"string\">\"rand\"</span>).(<span class=\"keyword\">string</span>) &#123;</div><div class=\"line\">\t\t\t\tf:=c.GetSession(<span class=\"string\">\"fluge\"</span>).(*models.Fluge)</div><div class=\"line\">\t\t\t\tc.DelSession(<span class=\"string\">\"fluge\"</span>)</div><div class=\"line\">\t\t\t\tc.DelSession(<span class=\"string\">\"rand\"</span>)</div><div class=\"line\">\t\t\t\tflag,_:=models.CheckUser(f)</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> flag &#123;</div><div class=\"line\">\t\t\t\t\tstr3, err := models.AddUser(f)</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, str3</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>, <span class=\"keyword\">int</span>(<span class=\"number\">4</span>))</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, str3</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>,<span class=\"keyword\">int</span>(<span class=\"number\">2</span>))</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"手机号无法重复绑定，请重新输入手机号\"</span></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"验证码错误，请重新输入\"</span></div><div class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:<span class=\"comment\">//用户已经完成绑定，等待退出</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> w.Content==<span class=\"string\">\"8\"</span> &#123;</div><div class=\"line\">\t\t\t\tc.DelSession(<span class=\"string\">\"bindstep\"</span>)</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>,<span class=\"string\">\"谢谢使用\"</span></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"绑定完成，请输入8退出\"</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\" \"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在这个程序是执行不了的。在beego中默认传递sessionId是cookie。但如果我在程序中必须使用session保持用户的状态（不然流程没办法继续下去）。两个服务器之间的交互式没有办法传递cookie。所以就会出现在一直在第一个流程，无法进入第二个流程。  </p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>首先明白一点，sessionId的作用是一个唯一标识符，用来标记同一个用户。但是在微信的整个架构中有一个跟sessionId很类似的东西:openid:用户对于某个公众号唯一的标识。所以在微信服务器向程序的服务器提交POST消息市本身也会自带这个openid。这样就为解决session提供了遍历。<br>不需要额外去产生和传递sessionId。直接使用openid来作为用户的唯一标识符。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%97%E6%B6%88%E6%81%AF.png\" alt=\"\"><br>然后对于sessionId对应的具体内容我选择了方便的redis来存储<br>实现代码–直接复写了beego的Getseeion和SetSession方法    </p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span><span class=\"title\">initSession</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\tconfig := &amp;redissession.SessionConfig&#123;</div><div class=\"line\">\t\tPrefix:<span class=\"string\">\"lyfluge-\"</span>,</div><div class=\"line\">\t\tRedisHost:<span class=\"string\">\"**********\"</span>,</div><div class=\"line\">\t\tRedisPassword:<span class=\"string\">\"f***********\"</span>,</div><div class=\"line\">\t\tLifeTime: <span class=\"number\">60</span> * time.Second,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tc.sesion = redissession.NewSession(<span class=\"string\">\"redis\"</span>,config)</div><div class=\"line\">\tc.sesion.SetSessionID(sid)</div><div class=\"line\">\tc.sesion.Start()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span><span class=\"title\">storeSession</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tc.sesion.Store()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">SetSession</span><span class=\"params\">(str <span class=\"keyword\">string</span>,value <span class=\"keyword\">interface</span>&#123;&#125;)</span><span class=\"title\">interface</span></span>&#123;&#125;&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> c.sesion.Set(str,value)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">GetSession</span><span class=\"params\">(str <span class=\"keyword\">string</span>)</span> <span class=\"title\">interface</span></span>&#123;&#125;&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> c.sesion.Get(str)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">DelSession</span><span class=\"params\">(str <span class=\"keyword\">string</span>)</span> <span class=\"title\">interface</span></span>&#123;&#125;&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> c.sesion.Delete(str)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//在Dispatch函数中取到对应的sessionId，然后进行状态判断</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">Dispatch</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"comment\">//进行请求的分发，和request数据的解析.POST</span></div><div class=\"line\">\tw := <span class=\"built_in\">new</span>(models.WeixinUser)</div><div class=\"line\">\txml.Unmarshal(c.Ctx.Input.RequestBody,&amp;w)</div><div class=\"line\">\tc.initSession(w.FromUserName)</div><div class=\"line\">   /..../</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>完整代码(包括微信golang的接入,大鱼短信,beego,session-redis的具体实现):</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>session中的sessionId是用来标志唯一用户的。通过找到这个用户来判断用户的状态  </p>\n<hr>\n<p>参考:<a href=\"http://harttle.com/2015/08/10/cookie-session.html\" target=\"_blank\" rel=\"external\">Cookie/Session的机制与安全</a></p>\n","excerpt":"<h3 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h3><p>首先有一点必须特别的清楚： 因为HTTP协议是无状态的，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，对于一个浏览器发出的多次请求，WEB服务器无法区分 是不是来源于同一个浏览器，更别说是否是来自同一用户。为了保持用户的状态，有了两种机制，一般用户客户端的cookie机制，和用于服务器端的session机制，这两种机制都是为了保持状态，既有联系又有区别。</p>\n<h3 id=\"cookie基本实现机制\"><a href=\"#cookie基本实现机制\" class=\"headerlink\" title=\"cookie基本实现机制\"></a>cookie基本实现机制</h3><p>现在的cookie是HTTP协议的一部分，一般存在HTTP的响应头，内容是一系列的键值对的形式，简单说：cookie就是服务器在用户的浏览器中存储的一小段文本文件（大小不能超过3K）不包含任何可执行代码，里面一般包含的是用户的登录信息之类的比较少的，用来验证用户是否合法（不止局限与此，cookie是用来记录状态的，也可以是购物的等一系列状态，让服务器知道我们浏览了那些地方，购物对那些感兴趣，一般很多广告都是根据这个东西来推送的，你在某购物网站买了一个东西，然后浏览别的网站，发现广告都是和你浏览的相关）。  cookie的内容主要包括：key-value,Expires（过期时间），path和domain。path和domain一起构成cookie的作用范围。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/cookie.png\" alt=\"\"><br>&emsp;&emsp;&emsp;&emsp;现在的cookie，内容经过加密了<br>cookie的实现流程：  </p>\n<ol>\n<li>浏览器向某个URL发起HTTP请求 （可以是任何请求，比如GET，POST等）</li>\n<li>对应的服务器收到该HTTP请求，并做相应的响应（响应头和请求体两部分），在响应的头中加入<code>Set-Cookie</code>字段（设置相应的cookie，cookie是多个<code>key-value</code>组成的）","more":"</li>\n<li>浏览器收到来自服务器的HTTP响应</li>\n<li>浏览器在响应头中发现存在<code>Set-Cookie</code>字段，就会将相应的cookie(key-value)保存在内存或者硬盘中。需要注意的是<code>Set-Value</code>字段可以包含多个cookie,每一项都可以指定过期时间，默认的过期的时间是用户浏览器关闭的时候</li>\n<li>浏览器下次给该服务器发送HTTP请求时，会将服务器设置的cookie附加在HTTP请求头<code>Cookie</code>中浏览器可以存储多个不同域名下的Cookie，但只发送当前请求的域名曾经指定的域名，这个可以在<code>Set-Cookie</code>中指定</li>\n<li>服务器收到这个HTTP请求，发现请求头中有<code>Cookie</code>字段，就知道这个用户的状态。获取相应的信息进行响应。<br>这就是整个基本的cookie机制。保存了用户的操作状态，但是还需要注意的是,cookies是通过明文传递。在HTTP包中容易被劫持和伪造，是不安全的，不应该存一些比较重要的东西。还有就是cookie在整个会话都会在HTTP的请求中，增加了流量。     </li>\n</ol>\n<h3 id=\"session的基本实现机制\"><a href=\"#session的基本实现机制\" class=\"headerlink\" title=\"session的基本实现机制\"></a>session的基本实现机制</h3><p>有一个session是不能改变的，是为了维持住HTTP的状态，所以在用户每次发起HTTP请求的时候，都需要让服务器知道是那个用户发起的这个请求，然后查找这个用户的状态，在进行相应的处理。session的实现基于这点，就需要一个唯一的ID标志某个用户（session）然后在这个ID中对应多个键值对来保证用户的状态，所以前后端只需要传递一个sessionId，服务器就可找到对应的状态（这个对应的键值对可以存在redies或者数据库中）。前后端传递值基本有三种：一种是直接写在URL中，一种通过表单中的隐藏域来提交，还有一种是现在流行的做法，通过在cookie中设置一个键值对<code>jsessionId=${sessionId}</code>在传递。现在第一二种都不是很建议这么做，当然在浏览器禁用的情况下也可以通过前面两种来传递，不过一般浏览器都支持使用cookie的方式。 </p>\n<h3 id=\"两种方式的区别和联系\"><a href=\"#两种方式的区别和联系\" class=\"headerlink\" title=\"两种方式的区别和联系\"></a>两种方式的区别和联系</h3><ol>\n<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>\n<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li>\n<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>考虑到减轻服务器性能方面，应当使用cookie。</li>\n<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>联系是：两个都是用来保持HTTP协议状态的方式，一种是客户端的实现，一种是服务器端的实现。但是session可以依赖于cookie来传递sessionId</li>\n</ol>\n<h3 id=\"一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题\"><a href=\"#一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题\" class=\"headerlink\" title=\"一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题\"></a>一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题</h3><p>首先简单描述下小项目:用户在公众号中输入某一个触发关键词（项目里面的例子是：绑定），然后就进入绑定所涉及的流程。用户在公众中输入触发词，是由微信的服务器进行响应，然后转发到程序的服务器。程序的服务器在把处理的结果（用规定的格式）传递给微信的服务器，由微信的服务器进行响应给用户。整个项目用golang开发，简单的使用了beego框架。</p>\n<h4 id=\"基于session来实现（初始版）\"><a href=\"#基于session来实现（初始版）\" class=\"headerlink\" title=\"基于session来实现（初始版）\"></a>基于session来实现（初始版）</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">Dispatch</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"comment\">//进行请求的分发，和request数据的解析,POST</span></div><div class=\"line\">\tw := <span class=\"built_in\">new</span>(models.WeixinUser)</div><div class=\"line\">\txml.Unmarshal(c.Ctx.Input.RequestBody,&amp;w)</div><div class=\"line\">\t<span class=\"comment\">//第一步是判断是否为开启逻辑的语句，同一个逻辑只能同时开启一次</span></div><div class=\"line\">\tstr:=w.Content</div><div class=\"line\">\tsc:=c.GetSession(<span class=\"string\">\"status-count\"</span>).(<span class=\"keyword\">int</span>)</div><div class=\"line\">\t<span class=\"keyword\">switch</span> str &#123;</div><div class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">\"绑定\"</span>: <span class=\"comment\">//如果匹配进入绑定，判断是否同时开启两次</span></div><div class=\"line\">\t\tstr0:=<span class=\"string\">\"\"</span></div><div class=\"line\">\t\tbinds:=assertionInt(c.GetSession(<span class=\"string\">\"bindstep\"</span>))</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> binds==<span class=\"number\">-1</span>&#123;</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>,<span class=\"keyword\">int</span>(<span class=\"number\">1</span>))</div><div class=\"line\">\t\t\tsc++;</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"status-count\"</span>,<span class=\"keyword\">int</span>(sc))</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"status-\"</span>+strconv.Itoa(sc),<span class=\"keyword\">string</span>(<span class=\"string\">\"bind\"</span>))</div><div class=\"line\">\t\t\t_,str0=bind(c,w)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> str0==<span class=\"string\">\"\"</span>&#123;</div><div class=\"line\">\t\t\tstr0=<span class=\"string\">\"已经进入绑定流程\"</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tprints(c,w,str0)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//第二步判断有多少个session保持者状态，从0开始计数,输入的数据从最上面的应用进行匹配处理</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> sc &gt;=<span class=\"number\">0</span> &#123;<span class=\"comment\">//判断是否有触发的逻辑</span></div><div class=\"line\">\t\t<span class=\"keyword\">for</span> i:=sc;i&gt;=<span class=\"number\">0</span>;i--&#123;<span class=\"comment\">//进行逻辑匹配</span></div><div class=\"line\">\t\t\tstr2:=c.GetSession(<span class=\"string\">\"status-\"</span>+strconv.Itoa(i)).(<span class=\"keyword\">string</span>)</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> str2!=<span class=\"string\">\"\"</span>&#123;</div><div class=\"line\">\t\t\t\tstr1:=<span class=\"string\">\" \"</span><span class=\"comment\">//进行默认的逻辑处理，不做回应</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> str2 &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"bind\"</span>:</div><div class=\"line\">\t\t\t\t\tcode,src:=bind(c,w)<span class=\"comment\">//code用来处理完成逻辑后的删除session的作用</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> code==<span class=\"number\">1</span>&#123;</div><div class=\"line\">\t\t\t\t\t\tc.DelSession(<span class=\"string\">\"status-\"</span>+strconv.Itoa(i))</div><div class=\"line\">\t\t\t\t\t\tc.SetSession(<span class=\"string\">\"status-count\"</span>,<span class=\"keyword\">int</span>(sc<span class=\"number\">-1</span>))</div><div class=\"line\">\t\t\t\t\t\tsc--;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\tstr1=src</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> str1 != <span class=\"string\">\" \"</span>&#123;<span class=\"comment\">//如果进行处理就退出逻辑</span></div><div class=\"line\">\t\t\t\t\tprints(c,w,str1)</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> str1 ==<span class=\"string\">\" \"</span>&amp;&amp;i==<span class=\"number\">0</span>&#123;</div><div class=\"line\">\t\t\t\t\tstr1=<span class=\"string\">\"输入格式错误\"</span></div><div class=\"line\">\t\t\t\t\tprints(c,w,str1)</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tstr=<span class=\"string\">\"输入：绑定，可以进入绑定流程\"</span></div><div class=\"line\">\tprints(c,w,str)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bind</span><span class=\"params\">(c *MainController,w *models.WeixinUser)</span> <span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\"><span class=\"comment\">//进行绑定请求的处理，如果匹配不上，退出同时开始另一个逻辑的匹配</span></div><div class=\"line\">\tstep:=c.GetSession(<span class=\"string\">\"bindstep\"</span>).(<span class=\"keyword\">string</span>)<span class=\"comment\">//内部逻辑计数器，记住用户的处理的位置，从1开始计数</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> step==<span class=\"number\">1</span>||step==<span class=\"number\">2</span>||step==<span class=\"number\">3</span>||step==<span class=\"number\">4</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">switch</span> step &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:<span class=\"comment\">//用户输入进入词，进入逻辑</span></div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>,<span class=\"keyword\">int</span>(<span class=\"number\">2</span>))</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"请输入手机号，进行绑定\"</span></div><div class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:<span class=\"comment\">//用户输入了手机号，发送短信，获取验证码</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//todo 验证手机号格式并且发短信验证验证码</span></div><div class=\"line\">\t\t\tok:=validatePhone(w.Content)</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"手机号格式不正确，请重新输入\"</span></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\talidayu.AppKey=<span class=\"string\">\"*******\"</span></div><div class=\"line\">\t\t\talidayu.AppSecret=<span class=\"string\">\"**************\"</span></div><div class=\"line\">\t\t\talidayu.UseHTTP=<span class=\"literal\">true</span></div><div class=\"line\">\t\t\tstr:=randNum()<span class=\"comment\">//生成随机4位数字</span></div><div class=\"line\">\t\t\tsuccess,_:=alidayu.SendSMS(w.Content,<span class=\"string\">\"德玛西亚\"</span>,<span class=\"string\">\"********\"</span>, <span class=\"string\">`&#123; \"code\":\"`</span>+str+<span class=\"string\">`\"&#125;`</span>)</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> !success&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"验证码发送失败，请重新输入手机号\"</span></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"rand\"</span>,str)</div><div class=\"line\">\t\t\tf:=models.Fluge&#123;&#125;</div><div class=\"line\">\t\t\tf.Openid=w.FromUserName</div><div class=\"line\">\t\t\tf.Phone=w.Content</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"fluge\"</span>,f)</div><div class=\"line\">\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>,<span class=\"keyword\">int</span>(<span class=\"number\">3</span>))</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"验证码已发送，请输入验证码完成绑定\"</span></div><div class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:<span class=\"comment\">//进行验证码的验证，成功就开始绑定</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> w.Content==c.GetSession(<span class=\"string\">\"rand\"</span>).(<span class=\"keyword\">string</span>) &#123;</div><div class=\"line\">\t\t\t\tf:=c.GetSession(<span class=\"string\">\"fluge\"</span>).(*models.Fluge)</div><div class=\"line\">\t\t\t\tc.DelSession(<span class=\"string\">\"fluge\"</span>)</div><div class=\"line\">\t\t\t\tc.DelSession(<span class=\"string\">\"rand\"</span>)</div><div class=\"line\">\t\t\t\tflag,_:=models.CheckUser(f)</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> flag &#123;</div><div class=\"line\">\t\t\t\t\tstr3, err := models.AddUser(f)</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, str3</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>, <span class=\"keyword\">int</span>(<span class=\"number\">4</span>))</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, str3</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tc.SetSession(<span class=\"string\">\"bindstep\"</span>,<span class=\"keyword\">int</span>(<span class=\"number\">2</span>))</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"手机号无法重复绑定，请重新输入手机号\"</span></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"验证码错误，请重新输入\"</span></div><div class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:<span class=\"comment\">//用户已经完成绑定，等待退出</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> w.Content==<span class=\"string\">\"8\"</span> &#123;</div><div class=\"line\">\t\t\t\tc.DelSession(<span class=\"string\">\"bindstep\"</span>)</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>,<span class=\"string\">\"谢谢使用\"</span></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\"绑定完成，请输入8退出\"</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>,<span class=\"string\">\" \"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在这个程序是执行不了的。在beego中默认传递sessionId是cookie。但如果我在程序中必须使用session保持用户的状态（不然流程没办法继续下去）。两个服务器之间的交互式没有办法传递cookie。所以就会出现在一直在第一个流程，无法进入第二个流程。  </p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>首先明白一点，sessionId的作用是一个唯一标识符，用来标记同一个用户。但是在微信的整个架构中有一个跟sessionId很类似的东西:openid:用户对于某个公众号唯一的标识。所以在微信服务器向程序的服务器提交POST消息市本身也会自带这个openid。这样就为解决session提供了遍历。<br>不需要额外去产生和传递sessionId。直接使用openid来作为用户的唯一标识符。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%97%E6%B6%88%E6%81%AF.png\" alt=\"\"><br>然后对于sessionId对应的具体内容我选择了方便的redis来存储<br>实现代码–直接复写了beego的Getseeion和SetSession方法    </p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span><span class=\"title\">initSession</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">\tconfig := &amp;redissession.SessionConfig&#123;</div><div class=\"line\">\t\tPrefix:<span class=\"string\">\"lyfluge-\"</span>,</div><div class=\"line\">\t\tRedisHost:<span class=\"string\">\"**********\"</span>,</div><div class=\"line\">\t\tRedisPassword:<span class=\"string\">\"f***********\"</span>,</div><div class=\"line\">\t\tLifeTime: <span class=\"number\">60</span> * time.Second,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tc.sesion = redissession.NewSession(<span class=\"string\">\"redis\"</span>,config)</div><div class=\"line\">\tc.sesion.SetSessionID(sid)</div><div class=\"line\">\tc.sesion.Start()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span><span class=\"title\">storeSession</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tc.sesion.Store()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">SetSession</span><span class=\"params\">(str <span class=\"keyword\">string</span>,value <span class=\"keyword\">interface</span>&#123;&#125;)</span><span class=\"title\">interface</span></span>&#123;&#125;&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> c.sesion.Set(str,value)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">GetSession</span><span class=\"params\">(str <span class=\"keyword\">string</span>)</span> <span class=\"title\">interface</span></span>&#123;&#125;&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> c.sesion.Get(str)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">DelSession</span><span class=\"params\">(str <span class=\"keyword\">string</span>)</span> <span class=\"title\">interface</span></span>&#123;&#125;&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> c.sesion.Delete(str)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//在Dispatch函数中取到对应的sessionId，然后进行状态判断</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MainController)</span> <span class=\"title\">Dispatch</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\t<span class=\"comment\">//进行请求的分发，和request数据的解析.POST</span></div><div class=\"line\">\tw := <span class=\"built_in\">new</span>(models.WeixinUser)</div><div class=\"line\">\txml.Unmarshal(c.Ctx.Input.RequestBody,&amp;w)</div><div class=\"line\">\tc.initSession(w.FromUserName)</div><div class=\"line\">   /..../</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>完整代码(包括微信golang的接入,大鱼短信,beego,session-redis的具体实现):</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>session中的sessionId是用来标志唯一用户的。通过找到这个用户来判断用户的状态  </p>\n<hr>\n<p>参考:<a href=\"http://harttle.com/2015/08/10/cookie-session.html\">Cookie/Session的机制与安全</a></p>"},{"title":"并发下的HashMap","date":"2016-12-29T09:52:18.000Z","_content":"从[HashMap并发的死循环](https://fluge.github.io/2016/12/15/HashMap%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/)可以知道,Hashmap是没办法在多线程的情况下使用的，为了解决这个问题，在Java4之前用的是hashtable,只是现在不推荐的。在Java5之后就比较推荐使用java.util.concurrent.ConcurrentHashMap，这个在多线程的情况下，也能有很好的性能。  \n### 并发的一些初步了解--synchronized和volatile  \n在多线程的并发的情况下有安全的访问变量，为了解决这个问题引入一个机制---锁机制。让多线程不能同时访问一个变量。在并发过程中有需要简单的了解两个东西的含义。\n#### Java中的synchronized的简单分析  \n`synchronized`的用法要弄清晰一个问题:`synchronized`锁住的是代码还是对象？\n首先是一个被`synchronized`修饰的代码块\n<!--more-->\n\n```java\n private static int count;\n    public SyncThread() {\n        count = 0;\n    }\n    public  void run() {\n        synchronized(this) {\n            for (int i = 0; i < 3; i++) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \":\" + (count++));\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n在来看两段程序，这个概念可以清晰很多\n\n```java\n//第一段代码\nSyncThread syncThread = new SyncThread();\nThread thread1 = new Thread(syncThread, \"Thread A\");\nThread thread2 = new Thread(syncThread, \"Thread B\");\nthread1.start();\nthread2.start();\n\n//第二段代码\nSyncThread syncThread1 = new SyncThread();\nSyncThread syncThread2 = new SyncThread();\nThread thread1 = new Thread(syncThread1, \"Thread A\");\nThread thread2 = new Thread(syncThread1, \"Thread B\");\nthread1.start();\nthread2.start();\n```\n这两段代码执行的结果:\n\n```java\n//第一段代码的执行结果，两个线程依次顺序执行\nThread A:0 \nThread A:1 \nThread A:2  \nThread B:3 \nThread B:4 \nThread B:5 \n//第二段代码的执行结果，两个线程轮流执行\nThread A:0 \nThread B:1 \nThread A:2 \nThread B:3 \nThread A:4 \nThread B:5 \n```\n第一个结果是A，B两个线程按照锁的方式，依次执行。第二个结果是两个线程不受锁的控制交替执行，为什么会出现这个情况呢？主要是因为第一段代码中`线程A和线程B`都是访问`syncThread`这个一个对象，必须按照获得锁的顺序执行。但是在第二段代码中`线程A`访问的是`syncThread1`,`线程B`访问的是`syncThread2`,`线程A执行的是syncThread1对象中的synchronized代码(run)`,线程B一样。这就可以知道`synchronized`锁住的是对象，这时会有两把锁分别锁定syncThread A对象和syncThread B对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。 \n`synchronized`是一种同步锁它修饰的对象有以下几种： \n1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，上文的例子就是代码块，作用的对象是调用这个代码块的对象； \n2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； \n3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个`类的所有对象`； \n4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个`类的所有对象`。  \n无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码\n#### Java中的volatile的简单分析\nVolatile是轻量级的synchronized，它在多处理器开发中保证了`共享变量`的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。\n想要彻底的理解`volatile`就必须理解Java的内存模型这个会在下一篇里文章讲到。关于`volatile`要知道就是每当线程要访问一个被volatile修饰的变量时都会从内存中直接拉取，而不会从缓存中获取这个变量的值。\n### Hashtable----几乎淘汰的遗留并发的HashMap  \n\n  \n----  \n参考:[Java中Synchronized的用法](http://blog.csdn.net/luoweifu/article/details/46613015)","source":"_posts/并发下的HashMap.md","raw":"---\ntitle: 并发下的HashMap\ndate: 2016-12-29 17:52:18\ncategories: \n- Java\ntags: \n- Java\n---\n从[HashMap并发的死循环](https://fluge.github.io/2016/12/15/HashMap%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/)可以知道,Hashmap是没办法在多线程的情况下使用的，为了解决这个问题，在Java4之前用的是hashtable,只是现在不推荐的。在Java5之后就比较推荐使用java.util.concurrent.ConcurrentHashMap，这个在多线程的情况下，也能有很好的性能。  \n### 并发的一些初步了解--synchronized和volatile  \n在多线程的并发的情况下有安全的访问变量，为了解决这个问题引入一个机制---锁机制。让多线程不能同时访问一个变量。在并发过程中有需要简单的了解两个东西的含义。\n#### Java中的synchronized的简单分析  \n`synchronized`的用法要弄清晰一个问题:`synchronized`锁住的是代码还是对象？\n首先是一个被`synchronized`修饰的代码块\n<!--more-->\n\n```java\n private static int count;\n    public SyncThread() {\n        count = 0;\n    }\n    public  void run() {\n        synchronized(this) {\n            for (int i = 0; i < 3; i++) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \":\" + (count++));\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n在来看两段程序，这个概念可以清晰很多\n\n```java\n//第一段代码\nSyncThread syncThread = new SyncThread();\nThread thread1 = new Thread(syncThread, \"Thread A\");\nThread thread2 = new Thread(syncThread, \"Thread B\");\nthread1.start();\nthread2.start();\n\n//第二段代码\nSyncThread syncThread1 = new SyncThread();\nSyncThread syncThread2 = new SyncThread();\nThread thread1 = new Thread(syncThread1, \"Thread A\");\nThread thread2 = new Thread(syncThread1, \"Thread B\");\nthread1.start();\nthread2.start();\n```\n这两段代码执行的结果:\n\n```java\n//第一段代码的执行结果，两个线程依次顺序执行\nThread A:0 \nThread A:1 \nThread A:2  \nThread B:3 \nThread B:4 \nThread B:5 \n//第二段代码的执行结果，两个线程轮流执行\nThread A:0 \nThread B:1 \nThread A:2 \nThread B:3 \nThread A:4 \nThread B:5 \n```\n第一个结果是A，B两个线程按照锁的方式，依次执行。第二个结果是两个线程不受锁的控制交替执行，为什么会出现这个情况呢？主要是因为第一段代码中`线程A和线程B`都是访问`syncThread`这个一个对象，必须按照获得锁的顺序执行。但是在第二段代码中`线程A`访问的是`syncThread1`,`线程B`访问的是`syncThread2`,`线程A执行的是syncThread1对象中的synchronized代码(run)`,线程B一样。这就可以知道`synchronized`锁住的是对象，这时会有两把锁分别锁定syncThread A对象和syncThread B对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。 \n`synchronized`是一种同步锁它修饰的对象有以下几种： \n1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，上文的例子就是代码块，作用的对象是调用这个代码块的对象； \n2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； \n3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个`类的所有对象`； \n4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个`类的所有对象`。  \n无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码\n#### Java中的volatile的简单分析\nVolatile是轻量级的synchronized，它在多处理器开发中保证了`共享变量`的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。\n想要彻底的理解`volatile`就必须理解Java的内存模型这个会在下一篇里文章讲到。关于`volatile`要知道就是每当线程要访问一个被volatile修饰的变量时都会从内存中直接拉取，而不会从缓存中获取这个变量的值。\n### Hashtable----几乎淘汰的遗留并发的HashMap  \n\n  \n----  \n参考:[Java中Synchronized的用法](http://blog.csdn.net/luoweifu/article/details/46613015)","slug":"并发下的HashMap","published":1,"updated":"2017-01-05T11:16:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2bts000gkhikkpvwcf29","content":"<p>从<a href=\"https://fluge.github.io/2016/12/15/HashMap%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/\" target=\"_blank\" rel=\"external\">HashMap并发的死循环</a>可以知道,Hashmap是没办法在多线程的情况下使用的，为了解决这个问题，在Java4之前用的是hashtable,只是现在不推荐的。在Java5之后就比较推荐使用java.util.concurrent.ConcurrentHashMap，这个在多线程的情况下，也能有很好的性能。  </p>\n<h3 id=\"并发的一些初步了解–synchronized和volatile\"><a href=\"#并发的一些初步了解–synchronized和volatile\" class=\"headerlink\" title=\"并发的一些初步了解–synchronized和volatile\"></a>并发的一些初步了解–synchronized和volatile</h3><p>在多线程的并发的情况下有安全的访问变量，为了解决这个问题引入一个机制—锁机制。让多线程不能同时访问一个变量。在并发过程中有需要简单的了解两个东西的含义。</p>\n<h4 id=\"Java中的synchronized的简单分析\"><a href=\"#Java中的synchronized的简单分析\" class=\"headerlink\" title=\"Java中的synchronized的简单分析\"></a>Java中的synchronized的简单分析</h4><p><code>synchronized</code>的用法要弄清晰一个问题:<code>synchronized</code>锁住的是代码还是对象？<br>首先是一个被<code>synchronized</code>修饰的代码块<br><a id=\"more\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SyncThread</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       count = <span class=\"number\">0</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">               <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                   System.out.println(Thread.currentThread().getName() + <span class=\"string\">\":\"</span> + (count++));</div><div class=\"line\">                   Thread.sleep(<span class=\"number\">100</span>);</div><div class=\"line\">               &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                   e.printStackTrace();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在来看两段程序，这个概念可以清晰很多</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//第一段代码</span></div><div class=\"line\">SyncThread syncThread = <span class=\"keyword\">new</span> SyncThread();</div><div class=\"line\">Thread thread1 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">\"Thread A\"</span>);</div><div class=\"line\">Thread thread2 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">\"Thread B\"</span>);</div><div class=\"line\">thread1.start();</div><div class=\"line\">thread2.start();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二段代码</span></div><div class=\"line\">SyncThread syncThread1 = <span class=\"keyword\">new</span> SyncThread();</div><div class=\"line\">SyncThread syncThread2 = <span class=\"keyword\">new</span> SyncThread();</div><div class=\"line\">Thread thread1 = <span class=\"keyword\">new</span> Thread(syncThread1, <span class=\"string\">\"Thread A\"</span>);</div><div class=\"line\">Thread thread2 = <span class=\"keyword\">new</span> Thread(syncThread1, <span class=\"string\">\"Thread B\"</span>);</div><div class=\"line\">thread1.start();</div><div class=\"line\">thread2.start();</div></pre></td></tr></table></figure>\n<p>这两段代码执行的结果:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//第一段代码的执行结果，两个线程依次顺序执行</span></div><div class=\"line\">Thread A:<span class=\"number\">0</span> </div><div class=\"line\">Thread A:<span class=\"number\">1</span> </div><div class=\"line\">Thread A:<span class=\"number\">2</span>  </div><div class=\"line\">Thread B:<span class=\"number\">3</span> </div><div class=\"line\">Thread B:<span class=\"number\">4</span> </div><div class=\"line\">Thread B:<span class=\"number\">5</span> </div><div class=\"line\"><span class=\"comment\">//第二段代码的执行结果，两个线程轮流执行</span></div><div class=\"line\">Thread A:<span class=\"number\">0</span> </div><div class=\"line\">Thread B:<span class=\"number\">1</span> </div><div class=\"line\">Thread A:<span class=\"number\">2</span> </div><div class=\"line\">Thread B:<span class=\"number\">3</span> </div><div class=\"line\">Thread A:<span class=\"number\">4</span> </div><div class=\"line\">Thread B:<span class=\"number\">5</span></div></pre></td></tr></table></figure>\n<p>第一个结果是A，B两个线程按照锁的方式，依次执行。第二个结果是两个线程不受锁的控制交替执行，为什么会出现这个情况呢？主要是因为第一段代码中<code>线程A和线程B</code>都是访问<code>syncThread</code>这个一个对象，必须按照获得锁的顺序执行。但是在第二段代码中<code>线程A</code>访问的是<code>syncThread1</code>,<code>线程B</code>访问的是<code>syncThread2</code>,<code>线程A执行的是syncThread1对象中的synchronized代码(run)</code>,线程B一样。这就可以知道<code>synchronized</code>锁住的是对象，这时会有两把锁分别锁定syncThread A对象和syncThread B对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。<br><code>synchronized</code>是一种同步锁它修饰的对象有以下几种： </p>\n<ol>\n<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，上文的例子就是代码块，作用的对象是调用这个代码块的对象； </li>\n<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>\n<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个<code>类的所有对象</code>； </li>\n<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个<code>类的所有对象</code>。<br>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码<h4 id=\"Java中的volatile的简单分析\"><a href=\"#Java中的volatile的简单分析\" class=\"headerlink\" title=\"Java中的volatile的简单分析\"></a>Java中的volatile的简单分析</h4>Volatile是轻量级的synchronized，它在多处理器开发中保证了<code>共享变量</code>的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>想要彻底的理解<code>volatile</code>就必须理解Java的内存模型这个会在下一篇里文章讲到。关于<code>volatile</code>要知道就是每当线程要访问一个被volatile修饰的变量时都会从内存中直接拉取，而不会从缓存中获取这个变量的值。<h3 id=\"Hashtable—-几乎淘汰的遗留并发的HashMap\"><a href=\"#Hashtable—-几乎淘汰的遗留并发的HashMap\" class=\"headerlink\" title=\"Hashtable—-几乎淘汰的遗留并发的HashMap\"></a>Hashtable—-几乎淘汰的遗留并发的HashMap</h3></li>\n</ol>\n<hr>\n<p>参考:<a href=\"http://blog.csdn.net/luoweifu/article/details/46613015\" target=\"_blank\" rel=\"external\">Java中Synchronized的用法</a></p>\n","excerpt":"<p>从<a href=\"https://fluge.github.io/2016/12/15/HashMap%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/\">HashMap并发的死循环</a>可以知道,Hashmap是没办法在多线程的情况下使用的，为了解决这个问题，在Java4之前用的是hashtable,只是现在不推荐的。在Java5之后就比较推荐使用java.util.concurrent.ConcurrentHashMap，这个在多线程的情况下，也能有很好的性能。  </p>\n<h3 id=\"并发的一些初步了解–synchronized和volatile\"><a href=\"#并发的一些初步了解–synchronized和volatile\" class=\"headerlink\" title=\"并发的一些初步了解–synchronized和volatile\"></a>并发的一些初步了解–synchronized和volatile</h3><p>在多线程的并发的情况下有安全的访问变量，为了解决这个问题引入一个机制—锁机制。让多线程不能同时访问一个变量。在并发过程中有需要简单的了解两个东西的含义。</p>\n<h4 id=\"Java中的synchronized的简单分析\"><a href=\"#Java中的synchronized的简单分析\" class=\"headerlink\" title=\"Java中的synchronized的简单分析\"></a>Java中的synchronized的简单分析</h4><p><code>synchronized</code>的用法要弄清晰一个问题:<code>synchronized</code>锁住的是代码还是对象？<br>首先是一个被<code>synchronized</code>修饰的代码块<br>","more":"</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SyncThread</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       count = <span class=\"number\">0</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">               <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                   System.out.println(Thread.currentThread().getName() + <span class=\"string\">\":\"</span> + (count++));</div><div class=\"line\">                   Thread.sleep(<span class=\"number\">100</span>);</div><div class=\"line\">               &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                   e.printStackTrace();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在来看两段程序，这个概念可以清晰很多</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//第一段代码</span></div><div class=\"line\">SyncThread syncThread = <span class=\"keyword\">new</span> SyncThread();</div><div class=\"line\">Thread thread1 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">\"Thread A\"</span>);</div><div class=\"line\">Thread thread2 = <span class=\"keyword\">new</span> Thread(syncThread, <span class=\"string\">\"Thread B\"</span>);</div><div class=\"line\">thread1.start();</div><div class=\"line\">thread2.start();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二段代码</span></div><div class=\"line\">SyncThread syncThread1 = <span class=\"keyword\">new</span> SyncThread();</div><div class=\"line\">SyncThread syncThread2 = <span class=\"keyword\">new</span> SyncThread();</div><div class=\"line\">Thread thread1 = <span class=\"keyword\">new</span> Thread(syncThread1, <span class=\"string\">\"Thread A\"</span>);</div><div class=\"line\">Thread thread2 = <span class=\"keyword\">new</span> Thread(syncThread1, <span class=\"string\">\"Thread B\"</span>);</div><div class=\"line\">thread1.start();</div><div class=\"line\">thread2.start();</div></pre></td></tr></table></figure>\n<p>这两段代码执行的结果:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//第一段代码的执行结果，两个线程依次顺序执行</span></div><div class=\"line\">Thread A:<span class=\"number\">0</span> </div><div class=\"line\">Thread A:<span class=\"number\">1</span> </div><div class=\"line\">Thread A:<span class=\"number\">2</span>  </div><div class=\"line\">Thread B:<span class=\"number\">3</span> </div><div class=\"line\">Thread B:<span class=\"number\">4</span> </div><div class=\"line\">Thread B:<span class=\"number\">5</span> </div><div class=\"line\"><span class=\"comment\">//第二段代码的执行结果，两个线程轮流执行</span></div><div class=\"line\">Thread A:<span class=\"number\">0</span> </div><div class=\"line\">Thread B:<span class=\"number\">1</span> </div><div class=\"line\">Thread A:<span class=\"number\">2</span> </div><div class=\"line\">Thread B:<span class=\"number\">3</span> </div><div class=\"line\">Thread A:<span class=\"number\">4</span> </div><div class=\"line\">Thread B:<span class=\"number\">5</span></div></pre></td></tr></table></figure>\n<p>第一个结果是A，B两个线程按照锁的方式，依次执行。第二个结果是两个线程不受锁的控制交替执行，为什么会出现这个情况呢？主要是因为第一段代码中<code>线程A和线程B</code>都是访问<code>syncThread</code>这个一个对象，必须按照获得锁的顺序执行。但是在第二段代码中<code>线程A</code>访问的是<code>syncThread1</code>,<code>线程B</code>访问的是<code>syncThread2</code>,<code>线程A执行的是syncThread1对象中的synchronized代码(run)</code>,线程B一样。这就可以知道<code>synchronized</code>锁住的是对象，这时会有两把锁分别锁定syncThread A对象和syncThread B对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。<br><code>synchronized</code>是一种同步锁它修饰的对象有以下几种： </p>\n<ol>\n<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，上文的例子就是代码块，作用的对象是调用这个代码块的对象； </li>\n<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>\n<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个<code>类的所有对象</code>； </li>\n<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个<code>类的所有对象</code>。<br>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码<h4 id=\"Java中的volatile的简单分析\"><a href=\"#Java中的volatile的简单分析\" class=\"headerlink\" title=\"Java中的volatile的简单分析\"></a>Java中的volatile的简单分析</h4>Volatile是轻量级的synchronized，它在多处理器开发中保证了<code>共享变量</code>的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>想要彻底的理解<code>volatile</code>就必须理解Java的内存模型这个会在下一篇里文章讲到。关于<code>volatile</code>要知道就是每当线程要访问一个被volatile修饰的变量时都会从内存中直接拉取，而不会从缓存中获取这个变量的值。<h3 id=\"Hashtable—-几乎淘汰的遗留并发的HashMap\"><a href=\"#Hashtable—-几乎淘汰的遗留并发的HashMap\" class=\"headerlink\" title=\"Hashtable—-几乎淘汰的遗留并发的HashMap\"></a>Hashtable—-几乎淘汰的遗留并发的HashMap</h3></li>\n</ol>\n<hr>\n<p>参考:<a href=\"http://blog.csdn.net/luoweifu/article/details/46613015\">Java中Synchronized的用法</a></p>"},{"title":"第一篇博客","date":"2016-11-25T08:42:04.000Z","_content":"### 开始写了有点小激动\n&emsp;&emsp;第一篇博客，其实以前也写过一些博文，但是都是不成体系的，一直都想写，但是总被一些事情给牵住了，终于可以开始第一篇博文的书写。这个博客主要记录我从大四实习开始的路程，不知道以后这个博客可以坚持多长时间，但是希望越久越好。我现在主要方向还是Java和golang的后端开发。因为两个的基础都不是很好。积累基础是一个很缓慢的过程，所以只能慢慢的往上爬。不能急。我会在博客中更新我最近学习的东西，和在工作中的坑。希望自己的技术能越来越来。说不定，以后就给自己的博客一个独立的域名，只是现在，刚开始。不急。","source":"_posts/第一篇博客.md","raw":"---\ntitle: 第一篇博客\ndate: 2016-11-25 16:42:04\ncategories: \n- essay\ntags:\n- start\n---\n### 开始写了有点小激动\n&emsp;&emsp;第一篇博客，其实以前也写过一些博文，但是都是不成体系的，一直都想写，但是总被一些事情给牵住了，终于可以开始第一篇博文的书写。这个博客主要记录我从大四实习开始的路程，不知道以后这个博客可以坚持多长时间，但是希望越久越好。我现在主要方向还是Java和golang的后端开发。因为两个的基础都不是很好。积累基础是一个很缓慢的过程，所以只能慢慢的往上爬。不能急。我会在博客中更新我最近学习的东西，和在工作中的坑。希望自己的技术能越来越来。说不定，以后就给自己的博客一个独立的域名，只是现在，刚开始。不急。","slug":"第一篇博客","published":1,"updated":"2016-12-05T04:33:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2btx000kkhikmvow7i6c","content":"<h3 id=\"开始写了有点小激动\"><a href=\"#开始写了有点小激动\" class=\"headerlink\" title=\"开始写了有点小激动\"></a>开始写了有点小激动</h3><p>&emsp;&emsp;第一篇博客，其实以前也写过一些博文，但是都是不成体系的，一直都想写，但是总被一些事情给牵住了，终于可以开始第一篇博文的书写。这个博客主要记录我从大四实习开始的路程，不知道以后这个博客可以坚持多长时间，但是希望越久越好。我现在主要方向还是Java和golang的后端开发。因为两个的基础都不是很好。积累基础是一个很缓慢的过程，所以只能慢慢的往上爬。不能急。我会在博客中更新我最近学习的东西，和在工作中的坑。希望自己的技术能越来越来。说不定，以后就给自己的博客一个独立的域名，只是现在，刚开始。不急。</p>\n","excerpt":"","more":"<h3 id=\"开始写了有点小激动\"><a href=\"#开始写了有点小激动\" class=\"headerlink\" title=\"开始写了有点小激动\"></a>开始写了有点小激动</h3><p>&emsp;&emsp;第一篇博客，其实以前也写过一些博文，但是都是不成体系的，一直都想写，但是总被一些事情给牵住了，终于可以开始第一篇博文的书写。这个博客主要记录我从大四实习开始的路程，不知道以后这个博客可以坚持多长时间，但是希望越久越好。我现在主要方向还是Java和golang的后端开发。因为两个的基础都不是很好。积累基础是一个很缓慢的过程，所以只能慢慢的往上爬。不能急。我会在博客中更新我最近学习的东西，和在工作中的坑。希望自己的技术能越来越来。说不定，以后就给自己的博客一个独立的域名，只是现在，刚开始。不急。</p>\n"},{"title":"跨域","date":"2016-12-14T13:05:01.000Z","_content":"### 同源策略 \n这套安全策略由Netscape提出，并延续至今。它规定：JavaScript脚本只能访问与其同一来源的资源(现在很多资源是通过ajax发起异步请求来获取的，如果没有跨域这个是禁止的)。  \n所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。严格隔离不相关的网站提供的内容，防止客户端数据机密性或完整性丢失。  \n假设你已经成功登录Gmail服务器，同时在同一个浏览器访问恶意站点（另一个浏览器选项卡）。没有同源策略，攻击者可以通过JavaScript获取你的用户信息，你的邮件以及其他敏感信息，比如说阅读你的私密邮件，发送虚假邮件，看你的聊天记录等等。假如把这个换成银行账户，那就很恐怖了。   \n可以说同源策略是现如今浏览器安全的基石。但是如果不能突破同源策略，把所有的资源放在同一服务器下，现在看来是不现实，必须有一中方式去平衡这种安全和便捷的机制--跨域。现在一般的跨域使用的是CORS(基本所有浏览器支持)和JSONP(一些比较的老的应用使用)。  \n### CROS跨域  \nCORS是一个W3C标准，全称是\"跨域资源共享\"(Cross-origin resource sharing)。它允许浏览器向跨源服务器,发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。  \n简单说一下我对CROS的理解。就相当于我想跟一个邻居借东西(浏览器向服务器发送跨域请求)。我首先要去敲门，然后就是几种情况，一种是邻居家里你敲门没有反应(服务器端没有设置跨域)，你跟不知道邻居家里的具体情况，借东西肯定是失败的。一种是邻居进行了应答，但是告诉你我跟你不熟，不借东西给你。另外一种就是邻居进行了应答，并借给你东西。\n<!--more-->  \n要了解CROS跨域，首先需要知道浏览器在ajax发起跨域请求的时候做了什么事。  \n`每次浏览器检查到这个请求是跨域请求时,会在请求的头部添加一些附加的头信息,根据请求的不同,有时会多发起一次请求`但是这些用户是感觉不到，前端的ajax调用也没有发什么变化,改变的是服务器端的回应。所以cros跨域由于浏览器的支持，现在只要在服务器端，也就是后端进行配置就可以了。  \n#### cros分类\n浏览器将cros的跨域请求分为两种:一种是简单请求，一种的非简单请求，两种的区别就是在发起非简单请求的时候，浏览器会在请求的前面先发起一次预请求，看请求的后端是否允许当前这个域名和这个方法进行访问。\n\n```java\n简单请求(不满足以下条件的都是非简单请求):\n(1)请求方法是以下三种方法之一:\nHEAD\nGET\nPOST\n(2)HTTP的头信息不超出以下几种字段:\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type:只限于三个值application/x-www-form-urlencoded 或 multipart/form-data 或text/plain\n```\n#### cros的简单请求\n对于简单请求的cros跨域请求,浏览器会在就是在头信息之中，增加一个`Origin`字段用来说明,本次请求来自哪个源(协议 + 域名 + 端口)服务器根据这个值，决定是否同意这次请求。  \n如果`Origin`的字段在服务器端允许的范围内,服务器成功响应,会在返回的头信息中多几个字段\n\n```java\n//该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\nAccess-Control-Allow-Origin: http://api.bob.com\n//该字段可选。它的值是一个布尔值，表示是否允许发送Cookie\nAccess-Control-Allow-Credentials: true\n//该字段可选。\nAccess-Control-Expose-Headers: FooBar\n```\n如果`Origin`指定的域名不在许可范围内。服务器也会正常的返回HTTP的回应(状态吗有可能是200)，只是头信息里面不会增加上面的字段。浏览器收到回应后 会检测是否有`Access-Control-Allow-Origin`字段，如果没有回抛出一个错误，被XMLHttpRequest的onerror回调函数捕获\n#### 非简单请求  \n非简单请求就是不满足简单请求条件的都是非简单请求，值得注意的是`Content-Type: application/josn`都是非简单请求。  \n浏览器如果检测到发起的请求是非简单请求，会在正式发起HTTP请求前,浏览器会自动发起一次HTTP查询请求，称为\"预检\"请求（preflight）。  \n预请求的方法是`OPTIONS`,这个方法和GET,POST等方法是一样的。这个方法表示请求是用来询问的服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。\n\n```java\n一个预检请求\nOPTIONS /cors HTTP/1.1\n//表示请求来自哪个源。\nOrigin: http://api.bob.com\n//该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，这个是PUT。\nAccess-Control-Request-Method: PUT\n//该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n\n预检请求允许,服务器端的回应\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\n//表示http://api.bob.com可以请求数据。该字段也可以设为*，表示同意任意跨源请求。\nAccess-Control-Allow-Origin: http://api.bob.com\n//该字段必需，表明服务器支持的所有跨域请求的方法。\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain;\n\n预检请求被否定时,跟简单请求一样会回复一个正常的HTTP请求,然后浏览器检查，被被XMLHttpRequest对象的onerror回调函数捕获就会报错\nXMLHttpRequest cannot load http://api.alice.com.\nOrigin http://api.bob.com is not allowed by Access-Control-Allow-Origin.\n```\n一旦服务器通过了\"预检\"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n#### beego的跨域\n在工作中用beego框架遇到的跨域问题的解决\n\n```golang\nfunc main() {\n\tbeego.InsertFilter(\"*\", beego.BeforeRouter,cors.Allow(&cors.Options{\n\t\t//允许的访问的域名\n\t\tAllowOrigins:  []string{\"*\"},\n\t\t//允许的访问的方法\n\t\tAllowMethods:  []string{\"OPTIONS\",\"GET\",\"PUT\",\"DELETE\",\"POST\"},\n\t\tAllowHeaders:  []string{\"Origin\"},\n\t\tExposeHeaders: []string{\"Content-Length\"},\n\t\tAllowCredentials: true,\n\t}))\n\tbeego.Run()\n}\n```\n#### JSONP的简介\nCORS与JSONP的使用目的相同，但是比JSONP更强大。\nJSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。\n\n\n----  \n参考:  \n[浏览器的同源策略及突破方法](http://blog.leanote.com/post/tamamoran/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E7%AA%81%E7%A0%B4%E6%96%B9%E6%B3%95)  \n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)","source":"_posts/跨域.md","raw":"---\ntitle: 跨域\ndate: 2016-12-14 21:05:01\ncategories: \n- web\ntags:\n- cros\n---\n### 同源策略 \n这套安全策略由Netscape提出，并延续至今。它规定：JavaScript脚本只能访问与其同一来源的资源(现在很多资源是通过ajax发起异步请求来获取的，如果没有跨域这个是禁止的)。  \n所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。严格隔离不相关的网站提供的内容，防止客户端数据机密性或完整性丢失。  \n假设你已经成功登录Gmail服务器，同时在同一个浏览器访问恶意站点（另一个浏览器选项卡）。没有同源策略，攻击者可以通过JavaScript获取你的用户信息，你的邮件以及其他敏感信息，比如说阅读你的私密邮件，发送虚假邮件，看你的聊天记录等等。假如把这个换成银行账户，那就很恐怖了。   \n可以说同源策略是现如今浏览器安全的基石。但是如果不能突破同源策略，把所有的资源放在同一服务器下，现在看来是不现实，必须有一中方式去平衡这种安全和便捷的机制--跨域。现在一般的跨域使用的是CORS(基本所有浏览器支持)和JSONP(一些比较的老的应用使用)。  \n### CROS跨域  \nCORS是一个W3C标准，全称是\"跨域资源共享\"(Cross-origin resource sharing)。它允许浏览器向跨源服务器,发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。  \n简单说一下我对CROS的理解。就相当于我想跟一个邻居借东西(浏览器向服务器发送跨域请求)。我首先要去敲门，然后就是几种情况，一种是邻居家里你敲门没有反应(服务器端没有设置跨域)，你跟不知道邻居家里的具体情况，借东西肯定是失败的。一种是邻居进行了应答，但是告诉你我跟你不熟，不借东西给你。另外一种就是邻居进行了应答，并借给你东西。\n<!--more-->  \n要了解CROS跨域，首先需要知道浏览器在ajax发起跨域请求的时候做了什么事。  \n`每次浏览器检查到这个请求是跨域请求时,会在请求的头部添加一些附加的头信息,根据请求的不同,有时会多发起一次请求`但是这些用户是感觉不到，前端的ajax调用也没有发什么变化,改变的是服务器端的回应。所以cros跨域由于浏览器的支持，现在只要在服务器端，也就是后端进行配置就可以了。  \n#### cros分类\n浏览器将cros的跨域请求分为两种:一种是简单请求，一种的非简单请求，两种的区别就是在发起非简单请求的时候，浏览器会在请求的前面先发起一次预请求，看请求的后端是否允许当前这个域名和这个方法进行访问。\n\n```java\n简单请求(不满足以下条件的都是非简单请求):\n(1)请求方法是以下三种方法之一:\nHEAD\nGET\nPOST\n(2)HTTP的头信息不超出以下几种字段:\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type:只限于三个值application/x-www-form-urlencoded 或 multipart/form-data 或text/plain\n```\n#### cros的简单请求\n对于简单请求的cros跨域请求,浏览器会在就是在头信息之中，增加一个`Origin`字段用来说明,本次请求来自哪个源(协议 + 域名 + 端口)服务器根据这个值，决定是否同意这次请求。  \n如果`Origin`的字段在服务器端允许的范围内,服务器成功响应,会在返回的头信息中多几个字段\n\n```java\n//该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\nAccess-Control-Allow-Origin: http://api.bob.com\n//该字段可选。它的值是一个布尔值，表示是否允许发送Cookie\nAccess-Control-Allow-Credentials: true\n//该字段可选。\nAccess-Control-Expose-Headers: FooBar\n```\n如果`Origin`指定的域名不在许可范围内。服务器也会正常的返回HTTP的回应(状态吗有可能是200)，只是头信息里面不会增加上面的字段。浏览器收到回应后 会检测是否有`Access-Control-Allow-Origin`字段，如果没有回抛出一个错误，被XMLHttpRequest的onerror回调函数捕获\n#### 非简单请求  \n非简单请求就是不满足简单请求条件的都是非简单请求，值得注意的是`Content-Type: application/josn`都是非简单请求。  \n浏览器如果检测到发起的请求是非简单请求，会在正式发起HTTP请求前,浏览器会自动发起一次HTTP查询请求，称为\"预检\"请求（preflight）。  \n预请求的方法是`OPTIONS`,这个方法和GET,POST等方法是一样的。这个方法表示请求是用来询问的服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。\n\n```java\n一个预检请求\nOPTIONS /cors HTTP/1.1\n//表示请求来自哪个源。\nOrigin: http://api.bob.com\n//该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，这个是PUT。\nAccess-Control-Request-Method: PUT\n//该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n\n预检请求允许,服务器端的回应\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\n//表示http://api.bob.com可以请求数据。该字段也可以设为*，表示同意任意跨源请求。\nAccess-Control-Allow-Origin: http://api.bob.com\n//该字段必需，表明服务器支持的所有跨域请求的方法。\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain;\n\n预检请求被否定时,跟简单请求一样会回复一个正常的HTTP请求,然后浏览器检查，被被XMLHttpRequest对象的onerror回调函数捕获就会报错\nXMLHttpRequest cannot load http://api.alice.com.\nOrigin http://api.bob.com is not allowed by Access-Control-Allow-Origin.\n```\n一旦服务器通过了\"预检\"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n#### beego的跨域\n在工作中用beego框架遇到的跨域问题的解决\n\n```golang\nfunc main() {\n\tbeego.InsertFilter(\"*\", beego.BeforeRouter,cors.Allow(&cors.Options{\n\t\t//允许的访问的域名\n\t\tAllowOrigins:  []string{\"*\"},\n\t\t//允许的访问的方法\n\t\tAllowMethods:  []string{\"OPTIONS\",\"GET\",\"PUT\",\"DELETE\",\"POST\"},\n\t\tAllowHeaders:  []string{\"Origin\"},\n\t\tExposeHeaders: []string{\"Content-Length\"},\n\t\tAllowCredentials: true,\n\t}))\n\tbeego.Run()\n}\n```\n#### JSONP的简介\nCORS与JSONP的使用目的相同，但是比JSONP更强大。\nJSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。\n\n\n----  \n参考:  \n[浏览器的同源策略及突破方法](http://blog.leanote.com/post/tamamoran/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E7%AA%81%E7%A0%B4%E6%96%B9%E6%B3%95)  \n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)","slug":"跨域","published":1,"updated":"2016-12-27T08:44:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2btz000mkhikdw4y0wzt","content":"<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><p>这套安全策略由Netscape提出，并延续至今。它规定：JavaScript脚本只能访问与其同一来源的资源(现在很多资源是通过ajax发起异步请求来获取的，如果没有跨域这个是禁止的)。<br>所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。严格隔离不相关的网站提供的内容，防止客户端数据机密性或完整性丢失。<br>假设你已经成功登录Gmail服务器，同时在同一个浏览器访问恶意站点（另一个浏览器选项卡）。没有同源策略，攻击者可以通过JavaScript获取你的用户信息，你的邮件以及其他敏感信息，比如说阅读你的私密邮件，发送虚假邮件，看你的聊天记录等等。假如把这个换成银行账户，那就很恐怖了。<br>可以说同源策略是现如今浏览器安全的基石。但是如果不能突破同源策略，把所有的资源放在同一服务器下，现在看来是不现实，必须有一中方式去平衡这种安全和便捷的机制–跨域。现在一般的跨域使用的是CORS(基本所有浏览器支持)和JSONP(一些比较的老的应用使用)。  </p>\n<h3 id=\"CROS跨域\"><a href=\"#CROS跨域\" class=\"headerlink\" title=\"CROS跨域\"></a>CROS跨域</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”(Cross-origin resource sharing)。它允许浏览器向跨源服务器,发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>简单说一下我对CROS的理解。就相当于我想跟一个邻居借东西(浏览器向服务器发送跨域请求)。我首先要去敲门，然后就是几种情况，一种是邻居家里你敲门没有反应(服务器端没有设置跨域)，你跟不知道邻居家里的具体情况，借东西肯定是失败的。一种是邻居进行了应答，但是告诉你我跟你不熟，不借东西给你。另外一种就是邻居进行了应答，并借给你东西。<br><a id=\"more\"></a><br>要了解CROS跨域，首先需要知道浏览器在ajax发起跨域请求的时候做了什么事。<br><code>每次浏览器检查到这个请求是跨域请求时,会在请求的头部添加一些附加的头信息,根据请求的不同,有时会多发起一次请求</code>但是这些用户是感觉不到，前端的ajax调用也没有发什么变化,改变的是服务器端的回应。所以cros跨域由于浏览器的支持，现在只要在服务器端，也就是后端进行配置就可以了。  </p>\n<h4 id=\"cros分类\"><a href=\"#cros分类\" class=\"headerlink\" title=\"cros分类\"></a>cros分类</h4><p>浏览器将cros的跨域请求分为两种:一种是简单请求，一种的非简单请求，两种的区别就是在发起非简单请求的时候，浏览器会在请求的前面先发起一次预请求，看请求的后端是否允许当前这个域名和这个方法进行访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">简单请求(不满足以下条件的都是非简单请求):</div><div class=\"line\">(<span class=\"number\">1</span>)请求方法是以下三种方法之一:</div><div class=\"line\"><span class=\"function\">HEAD</span></div><div class=\"line\">GET</div><div class=\"line\"><span class=\"title\">POST</span></div><div class=\"line\"><span class=\"params\">(<span class=\"number\">2</span>)</span>HTTP的头信息不超出以下几种字段:</div><div class=\"line\">Accept</div><div class=\"line\">Accept-Language</div><div class=\"line\">Content-Language</div><div class=\"line\">Last-Event-ID</div><div class=\"line\">Content-Type:只限于三个值application/x-www-form-urlencoded 或 multipart/form-data 或text/plain</div></pre></td></tr></table></figure>\n<h4 id=\"cros的简单请求\"><a href=\"#cros的简单请求\" class=\"headerlink\" title=\"cros的简单请求\"></a>cros的简单请求</h4><p>对于简单请求的cros跨域请求,浏览器会在就是在头信息之中，增加一个<code>Origin</code>字段用来说明,本次请求来自哪个源(协议 + 域名 + 端口)服务器根据这个值，决定是否同意这次请求。<br>如果<code>Origin</code>的字段在服务器端允许的范围内,服务器成功响应,会在返回的头信息中多几个字段</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</span></div><div class=\"line\">Access-Control-Allow-Origin: http:<span class=\"comment\">//api.bob.com</span></div><div class=\"line\"><span class=\"comment\">//该字段可选。它的值是一个布尔值，表示是否允许发送Cookie</span></div><div class=\"line\">Access-Control-Allow-Credentials: <span class=\"keyword\">true</span></div><div class=\"line\"><span class=\"comment\">//该字段可选。</span></div><div class=\"line\">Access-Control-Expose-Headers: FooBar</div></pre></td></tr></table></figure>\n<p>如果<code>Origin</code>指定的域名不在许可范围内。服务器也会正常的返回HTTP的回应(状态吗有可能是200)，只是头信息里面不会增加上面的字段。浏览器收到回应后 会检测是否有<code>Access-Control-Allow-Origin</code>字段，如果没有回抛出一个错误，被XMLHttpRequest的onerror回调函数捕获</p>\n<h4 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h4><p>非简单请求就是不满足简单请求条件的都是非简单请求，值得注意的是<code>Content-Type: application/josn</code>都是非简单请求。<br>浏览器如果检测到发起的请求是非简单请求，会在正式发起HTTP请求前,浏览器会自动发起一次HTTP查询请求，称为”预检”请求（preflight）。<br>预请求的方法是<code>OPTIONS</code>,这个方法和GET,POST等方法是一样的。这个方法表示请求是用来询问的服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">一个预检请求</div><div class=\"line\">OPTIONS /cors HTTP/<span class=\"number\">1.1</span></div><div class=\"line\"><span class=\"comment\">//表示请求来自哪个源。</span></div><div class=\"line\">Origin: http:<span class=\"comment\">//api.bob.com</span></div><div class=\"line\"><span class=\"comment\">//该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，这个是PUT。</span></div><div class=\"line\">Access-Control-Request-Method: PUT</div><div class=\"line\"><span class=\"comment\">//该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</span></div><div class=\"line\">Access-Control-Request-Headers: X-Custom-Header</div><div class=\"line\">Host: api.alice.com</div><div class=\"line\">Accept-Language: en-US</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">User-Agent: Mozilla/<span class=\"number\">5.0</span>...</div><div class=\"line\"></div><div class=\"line\">预检请求允许,服务器端的回应</div><div class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</div><div class=\"line\">Date: Mon, <span class=\"number\">01</span> Dec <span class=\"number\">2008</span> <span class=\"number\">01</span>:<span class=\"number\">15</span>:<span class=\"number\">39</span> GMT</div><div class=\"line\">Server: Apache/<span class=\"number\">2.0</span>.61 (Unix)</div><div class=\"line\"><span class=\"comment\">//表示http://api.bob.com可以请求数据。该字段也可以设为*，表示同意任意跨源请求。</span></div><div class=\"line\">Access-Control-Allow-Origin: http:<span class=\"comment\">//api.bob.com</span></div><div class=\"line\"><span class=\"comment\">//该字段必需，表明服务器支持的所有跨域请求的方法。</span></div><div class=\"line\">Access-Control-Allow-Methods: GET, POST, PUT</div><div class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</div><div class=\"line\">Content-Type: text/html; charset=utf-<span class=\"number\">8</span></div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Length: <span class=\"number\">0</span></div><div class=\"line\">Keep-Alive: timeout=<span class=\"number\">2</span>, max=<span class=\"number\">100</span></div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Type: text/plain;</div><div class=\"line\"></div><div class=\"line\">预检请求被否定时,跟简单请求一样会回复一个正常的HTTP请求,然后浏览器检查，被被XMLHttpRequest对象的onerror回调函数捕获就会报错</div><div class=\"line\">XMLHttpRequest cannot load http:<span class=\"comment\">//api.alice.com.</span></div><div class=\"line\">Origin http:<span class=\"comment\">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></div></pre></td></tr></table></figure>\n<p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>\n<h4 id=\"beego的跨域\"><a href=\"#beego的跨域\" class=\"headerlink\" title=\"beego的跨域\"></a>beego的跨域</h4><p>在工作中用beego框架遇到的跨域问题的解决</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tbeego.InsertFilter(<span class=\"string\">\"*\"</span>, beego.BeforeRouter,cors.Allow(&amp;cors.Options&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//允许的访问的域名</span></div><div class=\"line\">\t\tAllowOrigins:  []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"*\"</span>&#125;,</div><div class=\"line\">\t\t<span class=\"comment\">//允许的访问的方法</span></div><div class=\"line\">\t\tAllowMethods:  []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"OPTIONS\"</span>,<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"PUT\"</span>,<span class=\"string\">\"DELETE\"</span>,<span class=\"string\">\"POST\"</span>&#125;,</div><div class=\"line\">\t\tAllowHeaders:  []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Origin\"</span>&#125;,</div><div class=\"line\">\t\tExposeHeaders: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Content-Length\"</span>&#125;,</div><div class=\"line\">\t\tAllowCredentials: <span class=\"literal\">true</span>,</div><div class=\"line\">\t&#125;))</div><div class=\"line\">\tbeego.Run()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"JSONP的简介\"><a href=\"#JSONP的简介\" class=\"headerlink\" title=\"JSONP的简介\"></a>JSONP的简介</h4><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。<br>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>\n<hr>\n<p>参考:<br><a href=\"http://blog.leanote.com/post/tamamoran/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E7%AA%81%E7%A0%B4%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"external\">浏览器的同源策略及突破方法</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"external\">跨域资源共享 CORS 详解</a></p>\n","excerpt":"<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><p>这套安全策略由Netscape提出，并延续至今。它规定：JavaScript脚本只能访问与其同一来源的资源(现在很多资源是通过ajax发起异步请求来获取的，如果没有跨域这个是禁止的)。<br>所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。严格隔离不相关的网站提供的内容，防止客户端数据机密性或完整性丢失。<br>假设你已经成功登录Gmail服务器，同时在同一个浏览器访问恶意站点（另一个浏览器选项卡）。没有同源策略，攻击者可以通过JavaScript获取你的用户信息，你的邮件以及其他敏感信息，比如说阅读你的私密邮件，发送虚假邮件，看你的聊天记录等等。假如把这个换成银行账户，那就很恐怖了。<br>可以说同源策略是现如今浏览器安全的基石。但是如果不能突破同源策略，把所有的资源放在同一服务器下，现在看来是不现实，必须有一中方式去平衡这种安全和便捷的机制–跨域。现在一般的跨域使用的是CORS(基本所有浏览器支持)和JSONP(一些比较的老的应用使用)。  </p>\n<h3 id=\"CROS跨域\"><a href=\"#CROS跨域\" class=\"headerlink\" title=\"CROS跨域\"></a>CROS跨域</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”(Cross-origin resource sharing)。它允许浏览器向跨源服务器,发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>简单说一下我对CROS的理解。就相当于我想跟一个邻居借东西(浏览器向服务器发送跨域请求)。我首先要去敲门，然后就是几种情况，一种是邻居家里你敲门没有反应(服务器端没有设置跨域)，你跟不知道邻居家里的具体情况，借东西肯定是失败的。一种是邻居进行了应答，但是告诉你我跟你不熟，不借东西给你。另外一种就是邻居进行了应答，并借给你东西。<br>","more":"<br>要了解CROS跨域，首先需要知道浏览器在ajax发起跨域请求的时候做了什么事。<br><code>每次浏览器检查到这个请求是跨域请求时,会在请求的头部添加一些附加的头信息,根据请求的不同,有时会多发起一次请求</code>但是这些用户是感觉不到，前端的ajax调用也没有发什么变化,改变的是服务器端的回应。所以cros跨域由于浏览器的支持，现在只要在服务器端，也就是后端进行配置就可以了。  </p>\n<h4 id=\"cros分类\"><a href=\"#cros分类\" class=\"headerlink\" title=\"cros分类\"></a>cros分类</h4><p>浏览器将cros的跨域请求分为两种:一种是简单请求，一种的非简单请求，两种的区别就是在发起非简单请求的时候，浏览器会在请求的前面先发起一次预请求，看请求的后端是否允许当前这个域名和这个方法进行访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">简单请求(不满足以下条件的都是非简单请求):</div><div class=\"line\">(<span class=\"number\">1</span>)请求方法是以下三种方法之一:</div><div class=\"line\"><span class=\"function\">HEAD</div><div class=\"line\">GET</div><div class=\"line\"><span class=\"title\">POST</span></div><div class=\"line\"><span class=\"params\">(<span class=\"number\">2</span>)</span>HTTP的头信息不超出以下几种字段:</div><div class=\"line\">Accept</div><div class=\"line\">Accept-Language</div><div class=\"line\">Content-Language</div><div class=\"line\">Last-Event-ID</div><div class=\"line\">Content-Type:只限于三个值application/x-www-form-urlencoded 或 multipart/form-data 或text/plain</span></div></pre></td></tr></table></figure>\n<h4 id=\"cros的简单请求\"><a href=\"#cros的简单请求\" class=\"headerlink\" title=\"cros的简单请求\"></a>cros的简单请求</h4><p>对于简单请求的cros跨域请求,浏览器会在就是在头信息之中，增加一个<code>Origin</code>字段用来说明,本次请求来自哪个源(协议 + 域名 + 端口)服务器根据这个值，决定是否同意这次请求。<br>如果<code>Origin</code>的字段在服务器端允许的范围内,服务器成功响应,会在返回的头信息中多几个字段</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</span></div><div class=\"line\">Access-Control-Allow-Origin: http:<span class=\"comment\">//api.bob.com</span></div><div class=\"line\"><span class=\"comment\">//该字段可选。它的值是一个布尔值，表示是否允许发送Cookie</span></div><div class=\"line\">Access-Control-Allow-Credentials: <span class=\"keyword\">true</span></div><div class=\"line\"><span class=\"comment\">//该字段可选。</span></div><div class=\"line\">Access-Control-Expose-Headers: FooBar</div></pre></td></tr></table></figure>\n<p>如果<code>Origin</code>指定的域名不在许可范围内。服务器也会正常的返回HTTP的回应(状态吗有可能是200)，只是头信息里面不会增加上面的字段。浏览器收到回应后 会检测是否有<code>Access-Control-Allow-Origin</code>字段，如果没有回抛出一个错误，被XMLHttpRequest的onerror回调函数捕获</p>\n<h4 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h4><p>非简单请求就是不满足简单请求条件的都是非简单请求，值得注意的是<code>Content-Type: application/josn</code>都是非简单请求。<br>浏览器如果检测到发起的请求是非简单请求，会在正式发起HTTP请求前,浏览器会自动发起一次HTTP查询请求，称为”预检”请求（preflight）。<br>预请求的方法是<code>OPTIONS</code>,这个方法和GET,POST等方法是一样的。这个方法表示请求是用来询问的服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">一个预检请求</div><div class=\"line\">OPTIONS /cors HTTP/<span class=\"number\">1.1</span></div><div class=\"line\"><span class=\"comment\">//表示请求来自哪个源。</span></div><div class=\"line\">Origin: http:<span class=\"comment\">//api.bob.com</span></div><div class=\"line\"><span class=\"comment\">//该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，这个是PUT。</span></div><div class=\"line\">Access-Control-Request-Method: PUT</div><div class=\"line\"><span class=\"comment\">//该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</span></div><div class=\"line\">Access-Control-Request-Headers: X-Custom-Header</div><div class=\"line\">Host: api.alice.com</div><div class=\"line\">Accept-Language: en-US</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">User-Agent: Mozilla/<span class=\"number\">5.0</span>...</div><div class=\"line\"></div><div class=\"line\">预检请求允许,服务器端的回应</div><div class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</div><div class=\"line\">Date: Mon, <span class=\"number\">01</span> Dec <span class=\"number\">2008</span> <span class=\"number\">01</span>:<span class=\"number\">15</span>:<span class=\"number\">39</span> GMT</div><div class=\"line\">Server: Apache/<span class=\"number\">2.0</span>.61 (Unix)</div><div class=\"line\"><span class=\"comment\">//表示http://api.bob.com可以请求数据。该字段也可以设为*，表示同意任意跨源请求。</span></div><div class=\"line\">Access-Control-Allow-Origin: http:<span class=\"comment\">//api.bob.com</span></div><div class=\"line\"><span class=\"comment\">//该字段必需，表明服务器支持的所有跨域请求的方法。</span></div><div class=\"line\">Access-Control-Allow-Methods: GET, POST, PUT</div><div class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</div><div class=\"line\">Content-Type: text/html; charset=utf-<span class=\"number\">8</span></div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Length: <span class=\"number\">0</span></div><div class=\"line\">Keep-Alive: timeout=<span class=\"number\">2</span>, max=<span class=\"number\">100</span></div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Type: text/plain;</div><div class=\"line\"></div><div class=\"line\">预检请求被否定时,跟简单请求一样会回复一个正常的HTTP请求,然后浏览器检查，被被XMLHttpRequest对象的onerror回调函数捕获就会报错</div><div class=\"line\">XMLHttpRequest cannot load http:<span class=\"comment\">//api.alice.com.</span></div><div class=\"line\">Origin http:<span class=\"comment\">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></div></pre></td></tr></table></figure>\n<p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>\n<h4 id=\"beego的跨域\"><a href=\"#beego的跨域\" class=\"headerlink\" title=\"beego的跨域\"></a>beego的跨域</h4><p>在工作中用beego框架遇到的跨域问题的解决</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">\tbeego.InsertFilter(<span class=\"string\">\"*\"</span>, beego.BeforeRouter,cors.Allow(&amp;cors.Options&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//允许的访问的域名</span></div><div class=\"line\">\t\tAllowOrigins:  []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"*\"</span>&#125;,</div><div class=\"line\">\t\t<span class=\"comment\">//允许的访问的方法</span></div><div class=\"line\">\t\tAllowMethods:  []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"OPTIONS\"</span>,<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"PUT\"</span>,<span class=\"string\">\"DELETE\"</span>,<span class=\"string\">\"POST\"</span>&#125;,</div><div class=\"line\">\t\tAllowHeaders:  []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Origin\"</span>&#125;,</div><div class=\"line\">\t\tExposeHeaders: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Content-Length\"</span>&#125;,</div><div class=\"line\">\t\tAllowCredentials: <span class=\"literal\">true</span>,</div><div class=\"line\">\t&#125;))</div><div class=\"line\">\tbeego.Run()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"JSONP的简介\"><a href=\"#JSONP的简介\" class=\"headerlink\" title=\"JSONP的简介\"></a>JSONP的简介</h4><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。<br>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>\n<hr>\n<p>参考:<br><a href=\"http://blog.leanote.com/post/tamamoran/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E7%AA%81%E7%A0%B4%E6%96%B9%E6%B3%95\">浏览器的同源策略及突破方法</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解</a></p>"},{"title":"golang的切片和Java的动态数组","date":"2016-11-29T09:44:44.000Z","_content":"### Java里的动态数组---ArrayList  \nArrayList是实现List接口的动态数组，每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。随着向ArrayList中不断添加元素，容量会自动增长，自动增长会带来数据向新数组的*重新拷贝*。同时需要注意的是这个实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。(结构上的修改是指任何添加或删除一个或多个元素的的操作，或者显示调整底层数组的大小；仅仅设置元素的值不是结构上的修改)  \n<!--more-->\n#### Java里面的初始化和实现\n```java\n   public class ArrayList<E>   extends \t AbstractList<E>  implements   List<E>, RandomAccess, Cloneable, java.io.Serializable{\n \t\n     //设置arrayList默认容量\n     private static final int DEFAULT_CAPACITY = 10;\n \n     //空数组，当调用无参数构造函数的时候默认给个空数组\n     private static final Object[] EMPTY_ELEMENTDATA = {};\n \n     //这才是真正保存数据的数组\n     private transient Object[] elementData;\n \n     //arrayList的实际元素数量\n     private int size;\n \n     //构造方法传入默认的capacity 设置默认数组大小\n     public ArrayList(int initialCapacity) {\n         super();\n         if (initialCapacity < 0)\n             throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity);\n         this.elementData = new Object[initialCapacity];\n     }\n \n     //无参数构造方法默认为空数组\n     public ArrayList() {\n         super();\n         this.elementData = EMPTY_ELEMENTDATA;\n     }\n \n     //构造方法传入一个Collection， 则将Collection里面的值copy到arrayList\n     public ArrayList(Collection<? extends E> c) {\n         elementData = c.toArray();\n         size = elementData.length;\n         if (elementData.getClass() != Object[].class)\n             elementData = Arrays.copyOf(elementData, size, Object[].class);\n     }\n}\n```\n从上面的源码可以看出来，ArrayList的本质就是数组的，其中的add,get,set,remove等操作都是对数组的操作，所以ArrayList的特性基本都是源于数组:有序、元素可以重复、插入慢、获取快等特性。\n\n#### ArrayList里面的将数组动态扩容实现add和remove\n```java\n    //在末尾增加元素，虽然有时需要扩容但是时间复杂度为O(1)\n\tpublic boolean add(E e) {\n         ensureCapacityInternal(size + 1);  // Increments modCount!!\n         elementData[size++] = e;\n         return true;\n     }\n     //在数组中间增加元素，因为需要移动后面的元素，所以时间复杂度为O(n)\n     public void add(int index, E element) {\n         rangeCheckForAdd(index);\n \n         ensureCapacityInternal(size + 1);  // Increments modCount!!\n         System.arraycopy(elementData, index, elementData, index + 1,\n                          size - index);\n         elementData[index] = element;\n     } \n     private void ensureCapacityInternal(int minCapacity) {\n         if (elementData == EMPTY_ELEMENTDATA) {\n              minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n         }\n         ensureExplicitCapacity(minCapacity);\n      }\n      private void ensureExplicitCapacity(int minCapacity) {\n          modCount++;\n         //超出了数组可容纳的长度，需要进行动态扩展\n         if (minCapacity - elementData.length > 0)\n             grow(minCapacity);\n     }\n      //这才是动态扩展的核心\n     private void grow(int minCapacity) {\n         int oldCapacity = elementData.length;\n         //设置新数组的容量扩展为原来数组的1.5倍\n         int newCapacity = oldCapacity + (oldCapacity >> 1);\n         //再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度\n         if (newCapacity - minCapacity < 0)\n             newCapacity = minCapacity;\n         //判断有没超过最大限制\n         if (newCapacity - MAX_ARRAY_SIZE > 0)\n             newCapacity = hugeCapacity(minCapacity);\n         //将原来数组的值copy新数组中去\n         elementData = Arrays.copyOf(elementData, newCapacity);\n     }\n     private static int hugeCapacity(int minCapacity) {\n         if (minCapacity < 0) // overflow\n              throw new OutOfMemoryError();\n         return (minCapacity > MAX_ARRAY_SIZE) ?\n             Integer.MAX_VALUE :\n             MAX_ARRAY_SIZE;\n     }\n```\n从上面的ArrayList的源码就可以知道,整个ArrayList的动态实现就是在增加数据的时候判断数组的容量是否足够,不够就重新生成一个1.5倍的数组,然后进行复制。这就是整个ArrayList的核心。\n### golang里面的动态数组---slice\n#### Go中的数组定义\n在Go中的数组和Java有点不一样。在golang中数组是内置类型,初始化后长度是固定的，没有办法修改其长度,数组的长度也是其类型的一部分。数组是值类型,通过从0开始的下标索引访问元素值。值得注意的是如果GO中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝,而不是数组的指针。  \n![](http://ofa8x9gy9.bkt.clouddn.com/golang%E6%95%B0%E7%BB%84.png)  \n\n```go\nvar b [5]int //没有初始值，会自动的给出默认值{0,0,0,0,0}\na:=[5]int{1,2,3,4,5}\nb:=[...]int{1,2,3,4,5}\n```\n#### slice\n数组的长度是不可改变的,在很多场景都不是很适用，但是slice不一样。slice是golang的内置类型。在slice中有两个概念,和数组一样，有两个内置的属性：一个是len长度，一个是cap容量。slice是应用类型,因此当传递切片将和应用同一指针，修改值会影响其他的对象。\n\n```go\n//一般建议的初始化是用make()来初始化\nvar a []int\n```\n上面就可以表示一个slice,和声明数组差不多。只是少了一个长度。\nslice也可以从一个数组或者已经存在的`slice`中再次声明。`slice`通过`a[i:j]`来获取,其中i是数组的开始位置,j是结束位置(不包含),长度为j-i \n\n```go\n// 声明一个含有10个元素元素类型为byte的数组\nvar arr = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}\n\n// 声明两个含有byte的slice\nvar a, b ,c ,d[]byte\n// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: arr[2]、arr[3]和ar[4]\na = arr[2:5]\n// b是数组arr的另一个slice, b的元素是：arr[3]和arr[4]\nb = arr[3:5]\n//c是数组arr的另一个slice,c的元素师:arr[0],arr[1],arr[2]\nc = arr [:3]\n//slice的默认开始位置是0，arr[:n]等价于arr[0:n]\n//slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]\n//如果从一个数组里面直接获取slice，可以这样ar[:],因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]\n```\n基本结构如下：  \n![](http://ofa8x9gy9.bkt.clouddn.com/slice.png)   \n`slice`是引用类型,所以修改a中元素中的值，那么b中的值也会改变。\n对于slice有几个有用的内置函数：\n* `len()`获取slice的长度\n* `cap()`获取slice的最大容量\n* `append()` 向slice中追加一个或者多个元素，然后返回一个和slice一样类型的slice\n* `copy()` 从源slice的src中复制元素到目标dst，并且返回复制的元素的个数\nslice一般都是通过`make()`进行实例化操作,在进行扩容是用`append()`,如果直接加入的个数打入slice的初始容量会报错。\n\n```go\n//基本用法\nslice := append([]int{1,2,3},4,5,6)\n//合并两个slice\nslice := append([]int{1,2,3},[]int{4,5,6}...)\n//将字符串当作[]byte类型作为第二个参数传入\nbytes := append([]byte(\"hello\"),\"world\"...)\n```\n需要注意的是`append()`函数会改变slice的引用。cap不足时会按照cap的两倍进行扩容。\n### 有意思的算法---扩容\n首先有一个问题:在ArrayList中扩容是通过复制整个数组完成,每次当数组的容量满了，就会重新建一个长度是上次两倍的数组，然后进行复制操作，然后释放掉原来的数组。时间复杂度可以简单的看作使用for循环的嵌套，在复制数组的时候相当于用for循环来遍历了一遍数组。所以复制的时间复杂度应该是O(N)的。  \n但是整个ArrayList在末尾插入的时候表现是很快的。这里就有一个均摊的思想。  \n- 首先并不是每个元素的插入都会触发复制扩容这个操作。只有才数组长度不够的情况下，才会产生。然后均摊下来就是o(1)了。所以在某些情况下AarryList的性能会出现波动也是这个原因。\n\n\n\n\n","source":"_posts/golang的切片和Java的动态数组.md","raw":"---\ntitle: golang的切片和Java的动态数组\ndate: 2016-11-29 17:44:44\ncategories: \n- Java和golang\ntags: \n- golang\n- Java\n---\n### Java里的动态数组---ArrayList  \nArrayList是实现List接口的动态数组，每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。随着向ArrayList中不断添加元素，容量会自动增长，自动增长会带来数据向新数组的*重新拷贝*。同时需要注意的是这个实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。(结构上的修改是指任何添加或删除一个或多个元素的的操作，或者显示调整底层数组的大小；仅仅设置元素的值不是结构上的修改)  \n<!--more-->\n#### Java里面的初始化和实现\n```java\n   public class ArrayList<E>   extends \t AbstractList<E>  implements   List<E>, RandomAccess, Cloneable, java.io.Serializable{\n \t\n     //设置arrayList默认容量\n     private static final int DEFAULT_CAPACITY = 10;\n \n     //空数组，当调用无参数构造函数的时候默认给个空数组\n     private static final Object[] EMPTY_ELEMENTDATA = {};\n \n     //这才是真正保存数据的数组\n     private transient Object[] elementData;\n \n     //arrayList的实际元素数量\n     private int size;\n \n     //构造方法传入默认的capacity 设置默认数组大小\n     public ArrayList(int initialCapacity) {\n         super();\n         if (initialCapacity < 0)\n             throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity);\n         this.elementData = new Object[initialCapacity];\n     }\n \n     //无参数构造方法默认为空数组\n     public ArrayList() {\n         super();\n         this.elementData = EMPTY_ELEMENTDATA;\n     }\n \n     //构造方法传入一个Collection， 则将Collection里面的值copy到arrayList\n     public ArrayList(Collection<? extends E> c) {\n         elementData = c.toArray();\n         size = elementData.length;\n         if (elementData.getClass() != Object[].class)\n             elementData = Arrays.copyOf(elementData, size, Object[].class);\n     }\n}\n```\n从上面的源码可以看出来，ArrayList的本质就是数组的，其中的add,get,set,remove等操作都是对数组的操作，所以ArrayList的特性基本都是源于数组:有序、元素可以重复、插入慢、获取快等特性。\n\n#### ArrayList里面的将数组动态扩容实现add和remove\n```java\n    //在末尾增加元素，虽然有时需要扩容但是时间复杂度为O(1)\n\tpublic boolean add(E e) {\n         ensureCapacityInternal(size + 1);  // Increments modCount!!\n         elementData[size++] = e;\n         return true;\n     }\n     //在数组中间增加元素，因为需要移动后面的元素，所以时间复杂度为O(n)\n     public void add(int index, E element) {\n         rangeCheckForAdd(index);\n \n         ensureCapacityInternal(size + 1);  // Increments modCount!!\n         System.arraycopy(elementData, index, elementData, index + 1,\n                          size - index);\n         elementData[index] = element;\n     } \n     private void ensureCapacityInternal(int minCapacity) {\n         if (elementData == EMPTY_ELEMENTDATA) {\n              minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n         }\n         ensureExplicitCapacity(minCapacity);\n      }\n      private void ensureExplicitCapacity(int minCapacity) {\n          modCount++;\n         //超出了数组可容纳的长度，需要进行动态扩展\n         if (minCapacity - elementData.length > 0)\n             grow(minCapacity);\n     }\n      //这才是动态扩展的核心\n     private void grow(int minCapacity) {\n         int oldCapacity = elementData.length;\n         //设置新数组的容量扩展为原来数组的1.5倍\n         int newCapacity = oldCapacity + (oldCapacity >> 1);\n         //再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度\n         if (newCapacity - minCapacity < 0)\n             newCapacity = minCapacity;\n         //判断有没超过最大限制\n         if (newCapacity - MAX_ARRAY_SIZE > 0)\n             newCapacity = hugeCapacity(minCapacity);\n         //将原来数组的值copy新数组中去\n         elementData = Arrays.copyOf(elementData, newCapacity);\n     }\n     private static int hugeCapacity(int minCapacity) {\n         if (minCapacity < 0) // overflow\n              throw new OutOfMemoryError();\n         return (minCapacity > MAX_ARRAY_SIZE) ?\n             Integer.MAX_VALUE :\n             MAX_ARRAY_SIZE;\n     }\n```\n从上面的ArrayList的源码就可以知道,整个ArrayList的动态实现就是在增加数据的时候判断数组的容量是否足够,不够就重新生成一个1.5倍的数组,然后进行复制。这就是整个ArrayList的核心。\n### golang里面的动态数组---slice\n#### Go中的数组定义\n在Go中的数组和Java有点不一样。在golang中数组是内置类型,初始化后长度是固定的，没有办法修改其长度,数组的长度也是其类型的一部分。数组是值类型,通过从0开始的下标索引访问元素值。值得注意的是如果GO中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝,而不是数组的指针。  \n![](http://ofa8x9gy9.bkt.clouddn.com/golang%E6%95%B0%E7%BB%84.png)  \n\n```go\nvar b [5]int //没有初始值，会自动的给出默认值{0,0,0,0,0}\na:=[5]int{1,2,3,4,5}\nb:=[...]int{1,2,3,4,5}\n```\n#### slice\n数组的长度是不可改变的,在很多场景都不是很适用，但是slice不一样。slice是golang的内置类型。在slice中有两个概念,和数组一样，有两个内置的属性：一个是len长度，一个是cap容量。slice是应用类型,因此当传递切片将和应用同一指针，修改值会影响其他的对象。\n\n```go\n//一般建议的初始化是用make()来初始化\nvar a []int\n```\n上面就可以表示一个slice,和声明数组差不多。只是少了一个长度。\nslice也可以从一个数组或者已经存在的`slice`中再次声明。`slice`通过`a[i:j]`来获取,其中i是数组的开始位置,j是结束位置(不包含),长度为j-i \n\n```go\n// 声明一个含有10个元素元素类型为byte的数组\nvar arr = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}\n\n// 声明两个含有byte的slice\nvar a, b ,c ,d[]byte\n// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: arr[2]、arr[3]和ar[4]\na = arr[2:5]\n// b是数组arr的另一个slice, b的元素是：arr[3]和arr[4]\nb = arr[3:5]\n//c是数组arr的另一个slice,c的元素师:arr[0],arr[1],arr[2]\nc = arr [:3]\n//slice的默认开始位置是0，arr[:n]等价于arr[0:n]\n//slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]\n//如果从一个数组里面直接获取slice，可以这样ar[:],因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]\n```\n基本结构如下：  \n![](http://ofa8x9gy9.bkt.clouddn.com/slice.png)   \n`slice`是引用类型,所以修改a中元素中的值，那么b中的值也会改变。\n对于slice有几个有用的内置函数：\n* `len()`获取slice的长度\n* `cap()`获取slice的最大容量\n* `append()` 向slice中追加一个或者多个元素，然后返回一个和slice一样类型的slice\n* `copy()` 从源slice的src中复制元素到目标dst，并且返回复制的元素的个数\nslice一般都是通过`make()`进行实例化操作,在进行扩容是用`append()`,如果直接加入的个数打入slice的初始容量会报错。\n\n```go\n//基本用法\nslice := append([]int{1,2,3},4,5,6)\n//合并两个slice\nslice := append([]int{1,2,3},[]int{4,5,6}...)\n//将字符串当作[]byte类型作为第二个参数传入\nbytes := append([]byte(\"hello\"),\"world\"...)\n```\n需要注意的是`append()`函数会改变slice的引用。cap不足时会按照cap的两倍进行扩容。\n### 有意思的算法---扩容\n首先有一个问题:在ArrayList中扩容是通过复制整个数组完成,每次当数组的容量满了，就会重新建一个长度是上次两倍的数组，然后进行复制操作，然后释放掉原来的数组。时间复杂度可以简单的看作使用for循环的嵌套，在复制数组的时候相当于用for循环来遍历了一遍数组。所以复制的时间复杂度应该是O(N)的。  \n但是整个ArrayList在末尾插入的时候表现是很快的。这里就有一个均摊的思想。  \n- 首先并不是每个元素的插入都会触发复制扩容这个操作。只有才数组长度不够的情况下，才会产生。然后均摊下来就是o(1)了。所以在某些情况下AarryList的性能会出现波动也是这个原因。\n\n\n\n\n","slug":"golang的切片和Java的动态数组","published":1,"updated":"2016-12-29T08:33:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixka2bu3000rkhik77ue2ijt","content":"<h3 id=\"Java里的动态数组—ArrayList\"><a href=\"#Java里的动态数组—ArrayList\" class=\"headerlink\" title=\"Java里的动态数组—ArrayList\"></a>Java里的动态数组—ArrayList</h3><p>ArrayList是实现List接口的动态数组，每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。随着向ArrayList中不断添加元素，容量会自动增长，自动增长会带来数据向新数组的<em>重新拷贝</em>。同时需要注意的是这个实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。(结构上的修改是指任何添加或删除一个或多个元素的的操作，或者显示调整底层数组的大小；仅仅设置元素的值不是结构上的修改)<br><a id=\"more\"></a></p>\n<h4 id=\"Java里面的初始化和实现\"><a href=\"#Java里面的初始化和实现\" class=\"headerlink\" title=\"Java里面的初始化和实现\"></a>Java里面的初始化和实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt;   <span class=\"keyword\">extends</span> \t <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;  <span class=\"keyword\">implements</span>   <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</div><div class=\"line\"> \t</div><div class=\"line\">     <span class=\"comment\">//设置arrayList默认容量</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//空数组，当调用无参数构造函数的时候默认给个空数组</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//这才是真正保存数据的数组</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] elementData;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//arrayList的实际元素数量</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//构造方法传入默认的capacity 设置默认数组大小</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">super</span>();</div><div class=\"line\">         <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</div><div class=\"line\">             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+ initialCapacity);</div><div class=\"line\">         <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</div><div class=\"line\">     &#125;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//无参数构造方法默认为空数组</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">super</span>();</div><div class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class=\"line\">     &#125;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//构造方法传入一个Collection， 则将Collection里面的值copy到arrayList</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class=\"line\">         elementData = c.toArray();</div><div class=\"line\">         size = elementData.length;</div><div class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</div><div class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的源码可以看出来，ArrayList的本质就是数组的，其中的add,get,set,remove等操作都是对数组的操作，所以ArrayList的特性基本都是源于数组:有序、元素可以重复、插入慢、获取快等特性。</p>\n<h4 id=\"ArrayList里面的将数组动态扩容实现add和remove\"><a href=\"#ArrayList里面的将数组动态扩容实现add和remove\" class=\"headerlink\" title=\"ArrayList里面的将数组动态扩容实现add和remove\"></a>ArrayList里面的将数组动态扩容实现add和remove</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"comment\">//在末尾增加元素，虽然有时需要扩容但是时间复杂度为O(1)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></div><div class=\"line\">        elementData[size++] = e;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//在数组中间增加元素，因为需要移动后面的元素，所以时间复杂度为O(n)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</div><div class=\"line\">        rangeCheckForAdd(index);</div><div class=\"line\"></div><div class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></div><div class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</div><div class=\"line\">                         size - index);</div><div class=\"line\">        elementData[index] = element;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class=\"line\">             minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ensureExplicitCapacity(minCapacity);</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</div><div class=\"line\">         modCount++;</div><div class=\"line\">        <span class=\"comment\">//超出了数组可容纳的长度，需要进行动态扩展</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            grow(minCapacity);</div><div class=\"line\">    &#125;</div><div class=\"line\">     <span class=\"comment\">//这才是动态扩展的核心</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</div><div class=\"line\">        <span class=\"comment\">//设置新数组的容量扩展为原来数组的1.5倍</span></div><div class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"comment\">//再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</div><div class=\"line\">            newCapacity = minCapacity;</div><div class=\"line\">        <span class=\"comment\">//判断有没超过最大限制</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            newCapacity = hugeCapacity(minCapacity);</div><div class=\"line\">        <span class=\"comment\">//将原来数组的值copy新数组中去</span></div><div class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></div><div class=\"line\">             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</div><div class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class=\"line\">            Integer.MAX_VALUE :</div><div class=\"line\">            MAX_ARRAY_SIZE;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>从上面的ArrayList的源码就可以知道,整个ArrayList的动态实现就是在增加数据的时候判断数组的容量是否足够,不够就重新生成一个1.5倍的数组,然后进行复制。这就是整个ArrayList的核心。</p>\n<h3 id=\"golang里面的动态数组—slice\"><a href=\"#golang里面的动态数组—slice\" class=\"headerlink\" title=\"golang里面的动态数组—slice\"></a>golang里面的动态数组—slice</h3><h4 id=\"Go中的数组定义\"><a href=\"#Go中的数组定义\" class=\"headerlink\" title=\"Go中的数组定义\"></a>Go中的数组定义</h4><p>在Go中的数组和Java有点不一样。在golang中数组是内置类型,初始化后长度是固定的，没有办法修改其长度,数组的长度也是其类型的一部分。数组是值类型,通过从0开始的下标索引访问元素值。值得注意的是如果GO中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝,而不是数组的指针。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/golang%E6%95%B0%E7%BB%84.png\" alt=\"\">  </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> b [<span class=\"number\">5</span>]<span class=\"keyword\">int</span> <span class=\"comment\">//没有初始值，会自动的给出默认值&#123;0,0,0,0,0&#125;</span></div><div class=\"line\">a:=[<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\">b:=[...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p>数组的长度是不可改变的,在很多场景都不是很适用，但是slice不一样。slice是golang的内置类型。在slice中有两个概念,和数组一样，有两个内置的属性：一个是len长度，一个是cap容量。slice是应用类型,因此当传递切片将和应用同一指针，修改值会影响其他的对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一般建议的初始化是用make()来初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> a []<span class=\"keyword\">int</span></div></pre></td></tr></table></figure>\n<p>上面就可以表示一个slice,和声明数组差不多。只是少了一个长度。<br>slice也可以从一个数组或者已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>a[i:j]</code>来获取,其中i是数组的开始位置,j是结束位置(不包含),长度为j-i </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 声明一个含有10个元素元素类型为byte的数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>]<span class=\"keyword\">byte</span> &#123;<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'g'</span>, <span class=\"string\">'h'</span>, <span class=\"string\">'i'</span>, <span class=\"string\">'j'</span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明两个含有byte的slice</span></div><div class=\"line\"><span class=\"keyword\">var</span> a, b ,c ,d[]<span class=\"keyword\">byte</span></div><div class=\"line\"><span class=\"comment\">// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: arr[2]、arr[3]和ar[4]</span></div><div class=\"line\">a = arr[<span class=\"number\">2</span>:<span class=\"number\">5</span>]</div><div class=\"line\"><span class=\"comment\">// b是数组arr的另一个slice, b的元素是：arr[3]和arr[4]</span></div><div class=\"line\">b = arr[<span class=\"number\">3</span>:<span class=\"number\">5</span>]</div><div class=\"line\"><span class=\"comment\">//c是数组arr的另一个slice,c的元素师:arr[0],arr[1],arr[2]</span></div><div class=\"line\">c = arr [:<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"comment\">//slice的默认开始位置是0，arr[:n]等价于arr[0:n]</span></div><div class=\"line\"><span class=\"comment\">//slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</span></div><div class=\"line\"><span class=\"comment\">//如果从一个数组里面直接获取slice，可以这样ar[:],因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]</span></div></pre></td></tr></table></figure>\n<p>基本结构如下：<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/slice.png\" alt=\"\"><br><code>slice</code>是引用类型,所以修改a中元素中的值，那么b中的值也会改变。<br>对于slice有几个有用的内置函数：</p>\n<ul>\n<li><code>len()</code>获取slice的长度</li>\n<li><code>cap()</code>获取slice的最大容量</li>\n<li><code>append()</code> 向slice中追加一个或者多个元素，然后返回一个和slice一样类型的slice</li>\n<li><code>copy()</code> 从源slice的src中复制元素到目标dst，并且返回复制的元素的个数<br>slice一般都是通过<code>make()</code>进行实例化操作,在进行扩容是用<code>append()</code>,如果直接加入的个数打入slice的初始容量会报错。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//基本用法</span></div><div class=\"line\">slice := <span class=\"built_in\">append</span>([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"comment\">//合并两个slice</span></div><div class=\"line\">slice := <span class=\"built_in\">append</span>([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;...)</div><div class=\"line\"><span class=\"comment\">//将字符串当作[]byte类型作为第二个参数传入</span></div><div class=\"line\">bytes := <span class=\"built_in\">append</span>([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"hello\"</span>),<span class=\"string\">\"world\"</span>...)</div></pre></td></tr></table></figure>\n<p>需要注意的是<code>append()</code>函数会改变slice的引用。cap不足时会按照cap的两倍进行扩容。</p>\n<h3 id=\"有意思的算法—扩容\"><a href=\"#有意思的算法—扩容\" class=\"headerlink\" title=\"有意思的算法—扩容\"></a>有意思的算法—扩容</h3><p>首先有一个问题:在ArrayList中扩容是通过复制整个数组完成,每次当数组的容量满了，就会重新建一个长度是上次两倍的数组，然后进行复制操作，然后释放掉原来的数组。时间复杂度可以简单的看作使用for循环的嵌套，在复制数组的时候相当于用for循环来遍历了一遍数组。所以复制的时间复杂度应该是O(N)的。<br>但是整个ArrayList在末尾插入的时候表现是很快的。这里就有一个均摊的思想。  </p>\n<ul>\n<li>首先并不是每个元素的插入都会触发复制扩容这个操作。只有才数组长度不够的情况下，才会产生。然后均摊下来就是o(1)了。所以在某些情况下AarryList的性能会出现波动也是这个原因。</li>\n</ul>\n","excerpt":"<h3 id=\"Java里的动态数组—ArrayList\"><a href=\"#Java里的动态数组—ArrayList\" class=\"headerlink\" title=\"Java里的动态数组—ArrayList\"></a>Java里的动态数组—ArrayList</h3><p>ArrayList是实现List接口的动态数组，每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。随着向ArrayList中不断添加元素，容量会自动增长，自动增长会带来数据向新数组的<em>重新拷贝</em>。同时需要注意的是这个实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。(结构上的修改是指任何添加或删除一个或多个元素的的操作，或者显示调整底层数组的大小；仅仅设置元素的值不是结构上的修改)<br>","more":"</p>\n<h4 id=\"Java里面的初始化和实现\"><a href=\"#Java里面的初始化和实现\" class=\"headerlink\" title=\"Java里面的初始化和实现\"></a>Java里面的初始化和实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt;   <span class=\"keyword\">extends</span> \t <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;  <span class=\"keyword\">implements</span>   <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</div><div class=\"line\"> \t</div><div class=\"line\">     <span class=\"comment\">//设置arrayList默认容量</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//空数组，当调用无参数构造函数的时候默认给个空数组</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//这才是真正保存数据的数组</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] elementData;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//arrayList的实际元素数量</span></div><div class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//构造方法传入默认的capacity 设置默认数组大小</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">super</span>();</div><div class=\"line\">         <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</div><div class=\"line\">             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+ initialCapacity);</div><div class=\"line\">         <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</div><div class=\"line\">     &#125;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//无参数构造方法默认为空数组</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">super</span>();</div><div class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class=\"line\">     &#125;</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">//构造方法传入一个Collection， 则将Collection里面的值copy到arrayList</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class=\"line\">         elementData = c.toArray();</div><div class=\"line\">         size = elementData.length;</div><div class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</div><div class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的源码可以看出来，ArrayList的本质就是数组的，其中的add,get,set,remove等操作都是对数组的操作，所以ArrayList的特性基本都是源于数组:有序、元素可以重复、插入慢、获取快等特性。</p>\n<h4 id=\"ArrayList里面的将数组动态扩容实现add和remove\"><a href=\"#ArrayList里面的将数组动态扩容实现add和remove\" class=\"headerlink\" title=\"ArrayList里面的将数组动态扩容实现add和remove\"></a>ArrayList里面的将数组动态扩容实现add和remove</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"comment\">//在末尾增加元素，虽然有时需要扩容但是时间复杂度为O(1)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></div><div class=\"line\">        elementData[size++] = e;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//在数组中间增加元素，因为需要移动后面的元素，所以时间复杂度为O(n)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</div><div class=\"line\">        rangeCheckForAdd(index);</div><div class=\"line\"></div><div class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></div><div class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</div><div class=\"line\">                         size - index);</div><div class=\"line\">        elementData[index] = element;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class=\"line\">             minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ensureExplicitCapacity(minCapacity);</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</div><div class=\"line\">         modCount++;</div><div class=\"line\">        <span class=\"comment\">//超出了数组可容纳的长度，需要进行动态扩展</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            grow(minCapacity);</div><div class=\"line\">    &#125;</div><div class=\"line\">     <span class=\"comment\">//这才是动态扩展的核心</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</div><div class=\"line\">        <span class=\"comment\">//设置新数组的容量扩展为原来数组的1.5倍</span></div><div class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"comment\">//再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</div><div class=\"line\">            newCapacity = minCapacity;</div><div class=\"line\">        <span class=\"comment\">//判断有没超过最大限制</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</div><div class=\"line\">            newCapacity = hugeCapacity(minCapacity);</div><div class=\"line\">        <span class=\"comment\">//将原来数组的值copy新数组中去</span></div><div class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></div><div class=\"line\">             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</div><div class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class=\"line\">            Integer.MAX_VALUE :</div><div class=\"line\">            MAX_ARRAY_SIZE;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>从上面的ArrayList的源码就可以知道,整个ArrayList的动态实现就是在增加数据的时候判断数组的容量是否足够,不够就重新生成一个1.5倍的数组,然后进行复制。这就是整个ArrayList的核心。</p>\n<h3 id=\"golang里面的动态数组—slice\"><a href=\"#golang里面的动态数组—slice\" class=\"headerlink\" title=\"golang里面的动态数组—slice\"></a>golang里面的动态数组—slice</h3><h4 id=\"Go中的数组定义\"><a href=\"#Go中的数组定义\" class=\"headerlink\" title=\"Go中的数组定义\"></a>Go中的数组定义</h4><p>在Go中的数组和Java有点不一样。在golang中数组是内置类型,初始化后长度是固定的，没有办法修改其长度,数组的长度也是其类型的一部分。数组是值类型,通过从0开始的下标索引访问元素值。值得注意的是如果GO中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝,而不是数组的指针。<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/golang%E6%95%B0%E7%BB%84.png\" alt=\"\">  </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> b [<span class=\"number\">5</span>]<span class=\"keyword\">int</span> <span class=\"comment\">//没有初始值，会自动的给出默认值&#123;0,0,0,0,0&#125;</span></div><div class=\"line\">a:=[<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\">b:=[...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p>数组的长度是不可改变的,在很多场景都不是很适用，但是slice不一样。slice是golang的内置类型。在slice中有两个概念,和数组一样，有两个内置的属性：一个是len长度，一个是cap容量。slice是应用类型,因此当传递切片将和应用同一指针，修改值会影响其他的对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一般建议的初始化是用make()来初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> a []<span class=\"keyword\">int</span></div></pre></td></tr></table></figure>\n<p>上面就可以表示一个slice,和声明数组差不多。只是少了一个长度。<br>slice也可以从一个数组或者已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>a[i:j]</code>来获取,其中i是数组的开始位置,j是结束位置(不包含),长度为j-i </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 声明一个含有10个元素元素类型为byte的数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>]<span class=\"keyword\">byte</span> &#123;<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'g'</span>, <span class=\"string\">'h'</span>, <span class=\"string\">'i'</span>, <span class=\"string\">'j'</span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 声明两个含有byte的slice</span></div><div class=\"line\"><span class=\"keyword\">var</span> a, b ,c ,d[]<span class=\"keyword\">byte</span></div><div class=\"line\"><span class=\"comment\">// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: arr[2]、arr[3]和ar[4]</span></div><div class=\"line\">a = arr[<span class=\"number\">2</span>:<span class=\"number\">5</span>]</div><div class=\"line\"><span class=\"comment\">// b是数组arr的另一个slice, b的元素是：arr[3]和arr[4]</span></div><div class=\"line\">b = arr[<span class=\"number\">3</span>:<span class=\"number\">5</span>]</div><div class=\"line\"><span class=\"comment\">//c是数组arr的另一个slice,c的元素师:arr[0],arr[1],arr[2]</span></div><div class=\"line\">c = arr [:<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"comment\">//slice的默认开始位置是0，arr[:n]等价于arr[0:n]</span></div><div class=\"line\"><span class=\"comment\">//slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</span></div><div class=\"line\"><span class=\"comment\">//如果从一个数组里面直接获取slice，可以这样ar[:],因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]</span></div></pre></td></tr></table></figure>\n<p>基本结构如下：<br><img src=\"http://ofa8x9gy9.bkt.clouddn.com/slice.png\" alt=\"\"><br><code>slice</code>是引用类型,所以修改a中元素中的值，那么b中的值也会改变。<br>对于slice有几个有用的内置函数：</p>\n<ul>\n<li><code>len()</code>获取slice的长度</li>\n<li><code>cap()</code>获取slice的最大容量</li>\n<li><code>append()</code> 向slice中追加一个或者多个元素，然后返回一个和slice一样类型的slice</li>\n<li><code>copy()</code> 从源slice的src中复制元素到目标dst，并且返回复制的元素的个数<br>slice一般都是通过<code>make()</code>进行实例化操作,在进行扩容是用<code>append()</code>,如果直接加入的个数打入slice的初始容量会报错。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//基本用法</span></div><div class=\"line\">slice := <span class=\"built_in\">append</span>([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"comment\">//合并两个slice</span></div><div class=\"line\">slice := <span class=\"built_in\">append</span>([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;...)</div><div class=\"line\"><span class=\"comment\">//将字符串当作[]byte类型作为第二个参数传入</span></div><div class=\"line\">bytes := <span class=\"built_in\">append</span>([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"hello\"</span>),<span class=\"string\">\"world\"</span>...)</div></pre></td></tr></table></figure>\n<p>需要注意的是<code>append()</code>函数会改变slice的引用。cap不足时会按照cap的两倍进行扩容。</p>\n<h3 id=\"有意思的算法—扩容\"><a href=\"#有意思的算法—扩容\" class=\"headerlink\" title=\"有意思的算法—扩容\"></a>有意思的算法—扩容</h3><p>首先有一个问题:在ArrayList中扩容是通过复制整个数组完成,每次当数组的容量满了，就会重新建一个长度是上次两倍的数组，然后进行复制操作，然后释放掉原来的数组。时间复杂度可以简单的看作使用for循环的嵌套，在复制数组的时候相当于用for循环来遍历了一遍数组。所以复制的时间复杂度应该是O(N)的。<br>但是整个ArrayList在末尾插入的时候表现是很快的。这里就有一个均摊的思想。  </p>\n<ul>\n<li>首先并不是每个元素的插入都会触发复制扩容这个操作。只有才数组长度不够的情况下，才会产生。然后均摊下来就是o(1)了。所以在某些情况下AarryList的性能会出现波动也是这个原因。</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cixka2bti0008khik0aov6wll","category_id":"cixka2bt80005khikgcd9l94p","_id":"cixka2btr000ekhik0xdlark5"},{"post_id":"cixka2bsv0001khik9rpev2gw","category_id":"cixka2bt80005khikgcd9l94p","_id":"cixka2btx000jkhikh9ldddbe"},{"post_id":"cixka2bt10003khik0ct23h6p","category_id":"cixka2bto000akhik9uw6xsj4","_id":"cixka2bu0000nkhikzhwb4apb"},{"post_id":"cixka2bts000gkhikkpvwcf29","category_id":"cixka2bt80005khikgcd9l94p","_id":"cixka2bu4000skhikgymnf0wj"},{"post_id":"cixka2bte0007khikrg5kivxx","category_id":"cixka2bto000akhik9uw6xsj4","_id":"cixka2bu4000tkhik7iht1p66"},{"post_id":"cixka2bu3000rkhik77ue2ijt","category_id":"cixka2bu1000pkhikydpfz21v","_id":"cixka2bu6000xkhikn4442czm"},{"post_id":"cixka2btn0009khiki5j2pct3","category_id":"cixka2bu1000pkhikydpfz21v","_id":"cixka2bu6000zkhikk8revelb"},{"post_id":"cixka2btq000dkhikzks2h403","category_id":"cixka2bu5000ukhikkgxtbxjx","_id":"cixka2bua0013khik7qnjmnu1"},{"post_id":"cixka2btx000kkhikmvow7i6c","category_id":"cixka2bu80010khik69vqm0f1","_id":"cixka2bud0017khik3yaqru9c"},{"post_id":"cixka2btz000mkhikdw4y0wzt","category_id":"cixka2bu5000ukhikkgxtbxjx","_id":"cixka2bue001akhik4u13cbwu"}],"PostTag":[{"post_id":"cixka2bti0008khik0aov6wll","tag_id":"cixka2btd0006khikgw3znkz4","_id":"cixka2btp000ckhikqotpz4zd"},{"post_id":"cixka2bsv0001khik9rpev2gw","tag_id":"cixka2btd0006khikgw3znkz4","_id":"cixka2bts000fkhikzsjdh1qk"},{"post_id":"cixka2bt10003khik0ct23h6p","tag_id":"cixka2btp000bkhik1ukr63j2","_id":"cixka2bty000lkhikzjp5k1bg"},{"post_id":"cixka2bts000gkhikkpvwcf29","tag_id":"cixka2btd0006khikgw3znkz4","_id":"cixka2bu0000okhikrbxm615n"},{"post_id":"cixka2bte0007khikrg5kivxx","tag_id":"cixka2btv000ikhikj7xo2m6z","_id":"cixka2bu6000wkhika02e9ow7"},{"post_id":"cixka2bte0007khikrg5kivxx","tag_id":"cixka2bu2000qkhik5397h506","_id":"cixka2bu6000ykhikllxt5ovg"},{"post_id":"cixka2btn0009khiki5j2pct3","tag_id":"cixka2bu5000vkhikwjxv6otb","_id":"cixka2bua0012khika92yehj2"},{"post_id":"cixka2btn0009khiki5j2pct3","tag_id":"cixka2btd0006khikgw3znkz4","_id":"cixka2bub0014khikx4m3pt6k"},{"post_id":"cixka2btq000dkhikzks2h403","tag_id":"cixka2bu80011khikwlwp2w9o","_id":"cixka2bue0019khikob7l8z48"},{"post_id":"cixka2btq000dkhikzks2h403","tag_id":"cixka2buc0016khik6nz2p6ur","_id":"cixka2bue001bkhikekm16lqi"},{"post_id":"cixka2btx000kkhikmvow7i6c","tag_id":"cixka2bue0018khikmpx17peu","_id":"cixka2buf001dkhikruddhzka"},{"post_id":"cixka2btz000mkhikdw4y0wzt","tag_id":"cixka2buf001ckhikupj6axxt","_id":"cixka2bug001fkhikjuoh4czi"},{"post_id":"cixka2bu3000rkhik77ue2ijt","tag_id":"cixka2bu5000vkhikwjxv6otb","_id":"cixka2buh001gkhik0vjbeg2r"},{"post_id":"cixka2bu3000rkhik77ue2ijt","tag_id":"cixka2btd0006khikgw3znkz4","_id":"cixka2buh001hkhiktn18i3y9"}],"Tag":[{"name":"Java","_id":"cixka2btd0006khikgw3znkz4"},{"name":"ip","_id":"cixka2btp000bkhik1ukr63j2"},{"name":"ICMP","_id":"cixka2btv000ikhikj7xo2m6z"},{"name":"UDP","_id":"cixka2bu2000qkhik5397h506"},{"name":"golang","_id":"cixka2bu5000vkhikwjxv6otb"},{"name":"session","_id":"cixka2bu80011khikwlwp2w9o"},{"name":"cookie","_id":"cixka2buc0016khik6nz2p6ur"},{"name":"start","_id":"cixka2bue0018khikmpx17peu"},{"name":"cros","_id":"cixka2buf001ckhikupj6axxt"}]}}